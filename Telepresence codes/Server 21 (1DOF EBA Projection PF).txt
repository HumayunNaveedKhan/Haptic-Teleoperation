#include <stdio.h>
#include <chrono>
#include <winsock2.h>
#include "chai3d.h"
#include <GLFW/glfw3.h>
#include "widgets/CScope.h"
#include "graphics/CPrimitives.h"
#pragma comment(lib, "ws2_32.lib")
#include <ctime>
#include <string>

//////////////////////////////////////////////////
using namespace chai3d;
using namespace std;
// Device Param.
#define DOF 3
//double rbuf[3];

const int BUFFER_SIZE = 2048;
const int OUTPUT_INTERVAL_SECONDS = 1;
char buffer[BUFFER_SIZE];

double pos_curr[DOF] = { 0, 0, 0 };
double pos_prev[DOF] = { 0, 0, 0 };
double pos_recv[DOF] = { 0, 0, 0 };
double Fd[DOF] = { 0, 0, 0 };
double dFe[DOF] = { 0, 0, 0 };
double Xd[DOF];
double DXd[DOF];
double XdP[DOF];
double timeUDPRr;
bool nProjection = true;
double FOR_Mag;
double ProjFOR[3], UnitV[3];// EBA_FOR;
double InnerProduct;
time_t timestamp2;
time_t timestamp1;
//								EBA Parameters							//
double uBETA[3], BETA[3], Bmax[3], Bmin[3];
double c1 = 70;
double c2 = 105;
double Th, Tc;
//							Flag Parameters								//
bool EnableEBA = true;
// UDP Param.
#define BUFSIZE 2048
/////////////////////
#define Buffer 2048
/////////////////////
#define SERVER_IP "169.254.153.189"//"192.168.0.107"//"169.254.153.189" //"192.168.4.3"  // "127.0.0.1" // "111.68.110.189" // "203.237.55.14"
#define UDP_PORT 4000
#define SENDDATA_NUM 1
#define READDATA_NUM 1
string Server = SERVER_IP;
string Server2;
int retval;
WSADATA wsa;
int TAP;
double avg_delay;
SOCKET sock;
// µ¥ÀÌÅÍ Åë½Å¿¡ »ç¿ëÇÒ º¯¼ö
SOCKADDR_IN serveraddr;
SOCKADDR_IN clientaddr;
int addrlen;
///////////////////////
char sbuff[Buffer], rbuff[Buffer];
///////////////////////
char sbuf[BUFSIZE + 1], rbuf[BUFSIZE + 1];
float SendData[SENDDATA_NUM], ReadData[READDATA_NUM];
bool isFirstRecv = false;
int timeUDPR;
int timeUDPS;
double delay = 0;
double delaym = 0;
int countd = 0;
struct Timer
{
	chrono::time_point<std::chrono::steady_clock>start, end;
	chrono::duration<float>duration;
	Timer()
	{
		start = std::chrono::high_resolution_clock::now();

	}
	~Timer()
	{
		end = std::chrono::high_resolution_clock::now();
		duration = end - start;
		float ms = duration.count() * 1000.0f;
		timeUDPR = ms;
		//cout << "Timer took" << ms << "ms" << endl;

	}
};
struct Timer2
{
	chrono::time_point<std::chrono::steady_clock>start, end;
	chrono::duration<float>duration;
	Timer2()
	{
		start = std::chrono::high_resolution_clock::now();

	}
	~Timer2()
	{
		end = std::chrono::high_resolution_clock::now();
		duration = end - start;
		float ms = duration.count() * 1000.0f;
		timeUDPS = ms;
		//cout << "Timer took" << ms << "ms" << endl;

	}
};
// Delay Param.
#define DELAY 1
#define DELAYDATA_NUM 3
double ClientData[DELAYDATA_NUM];
double DelayDataBuf[DELAYDATA_NUM][DELAY];
double DelayData[DELAYDATA_NUM];
// GUI - GENERAL SETTINGS
cStereoMode stereoMode = C_STEREO_DISABLED;
// fullscreen mode
bool fullscreen = false;
// mirrored display
bool mirroredDisplay = false;
////////////////////////////////////////////////////////////////////////////////
// GUI - DECLARED VARIABLES
////////////////////////////////////////////////////////////////////////////////

	// a world that contains all objects of the virtual environment
cWorld* world;

// a camera to render the world in the window display
cCamera* camera;

// a light source to illuminate the objects in the world
cDirectionalLight* light;

// a haptic device handler
cHapticDeviceHandler* handler;

// a pointer to the current haptic device
cGenericHapticDevicePtr hapticDevice;

// a label to display the haptic device model
cLabel* labelHapticDeviceModel;

// a label to display the position [m] of the haptic device
cLabel* labelHapticDevicePosition;

// a global variable to store the position [m] of the haptic device
cVector3d hapticDevicePosition;

// a global variable to store the velocity [m/s] of the haptic device
cVector3d hapticDeviceVelocity;

// a font for rendering text
cFontPtr font;

// a label to display the rate [Hz] at which the simulation is running
cLabel* labelRates;
cLabel* labelMax;
cLabel* labelMin;
cLabel* labelXd;
cLabel* labelXd_Prev;
cLabel* labelX_Recv;
cLabel* labelFd;
cLabel* labeldFe;
cLabel* labelIP;
cLabel* labelDelay;
cLabel* labelc1;
cLabel* labelc2;
cLabel* labelbuff;
cLabel* scopename;
cLabel* labeldelay2;
cLabel* labeldelay3;
cLabel* labelProjFOR;
cLabel* labelSlave_force;
// a small sphere (cursor) representing the haptic device 
cShapeTorus* cursor;
// a line representing the velocity of the haptic device
cShapeLine* velocity;
// a scope to monitor position values of haptic device
cScope* scope0;
cScope* scope1;
cScope* scope2;
cScope* scope3;
cScope* scope4;
cScope* scope5;

cLevel* leveldelay;
// a flag for using force field (ON/OFF)
bool useForceField = true;

// a flag to indicate if the haptic simulation currently running
bool simulationRunning = false;

// a flag to indicate if the haptic simulation has terminated
bool simulationFinished = true;

// a frequency counter to measure the simulation graphic rate
cFrequencyCounter freqCounterGraphics;

// a frequency counter to measure the simulation haptic rate
cFrequencyCounter freqCounterHaptics;

// haptic thread
cThread* hapticsThread;

// a handle to window display context
GLFWwindow* window = NULL;

// current width of window
int width = 0;

// current height of window
int height = 0;

// swap interval for the display context (vertical synchronization)
int swapInterval = 1;
////////////////////////////////////////////////////////////////////////////////
// GUI - DECLARED FUNCTIONS
////////////////////////////////////////////////////////////////////////////////

// callback when the window display is resized
void windowSizeCallback(GLFWwindow* a_window, int a_width, int a_height);

// callback when an error GLFW occurs
void errorCallback(int error, const char* a_description);

// callback when a key is pressed
void keyCallback(GLFWwindow* a_window, int a_key, int a_scancode, int a_action, int a_mods);

// this function renders the scene
void updateGraphics(void);

// this function contains the main haptics simulation loop
void updateHaptics(void);

// this function closes the application
void close(void);

void InitUDP(void);
//void modifiedEBA(void);
void CloseUDP();
void UDPSendData(float sData[SENDDATA_NUM]);
void UDPReadData();
void err_quit(const char* msg);
void err_display(const char* msg);

/////////////////////////////////////////////////////////////

int main(int argc, char* argv[])
{
	InitUDP();

	////////////////////////////////////////////////////////////////////////////////
	// INITIALIZATION
	////////////////////////////////////////////////////////////////////////////////

	cout << endl;
	cout << "-------------------------------------" << endl;
	cout << "Dr. Riaz Uddin Teleoperation (Master)" << endl;
	cout << "-------------------------------------" << endl << endl << endl;
	cout << "Keyboard Options:" << endl << endl;
	cout << "[1] - Enable/Disable potential field" << endl;
	cout << "[f] - toggle fullscreen" << endl;
	cout << "[M] - Mirrored Display" << endl;
	cout << endl;
	cout << "Haptic Device Controls:" << endl;
	cout << "----------------------" << endl;
	cout << "[button3] - Increase Delay" << endl;
	cout << "[button2] - Increase damping" << endl;
	cout << "[button1] - Decrease damping" << endl;
	cout << "[button0] - Normalize damping and delay" << endl;
	cout << endl;
	cout << "[q] - Exit application" << endl;
	cout << endl;
	//cout << "********************" << endl;
	////////////////////////////////////////////////////////////////////////////////
	// OPEN GL - WINDOW DISPLAY
	////////////////////////////////////////////////////////////////////////////////

	// initialize GLFW library
	if (!glfwInit())
	{
		cout << "failed initialization" << endl;
		cSleepMs(1000);
		return 1;
	}

	// set error callback
	glfwSetErrorCallback(errorCallback);

	// compute desired size of window
	const GLFWvidmode* mode = glfwGetVideoMode(glfwGetPrimaryMonitor());
	int w = 0.8 * mode->height;
	int h = 0.5 * mode->height;
	int x = 0.5 * (mode->width - w);
	int y = 0.5 * (mode->height - h);

	// set OpenGL version
	glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 2);
	glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 1);

	// set active stereo mode
	if (stereoMode == C_STEREO_ACTIVE)
	{
		glfwWindowHint(GLFW_STEREO, GL_TRUE);
	}
	else
	{
		glfwWindowHint(GLFW_STEREO, GL_FALSE);
	}
	// create display context
	window = glfwCreateWindow(w, h, "Dr. Riazuddin Teleoperation (SERVER)", NULL, NULL);
	if (!window)
	{
		cout << "failed to create window" << endl;
		cSleepMs(10);
		glfwTerminate();
		return 1;
	}
	// get width and height of window
	glfwGetWindowSize(window, &width, &height);

	// set position of window
	glfwSetWindowPos(window, x, y);

	// set key callback
	glfwSetKeyCallback(window, keyCallback);

	// set resize callback
	glfwSetWindowSizeCallback(window, windowSizeCallback);

	// set current display context
	glfwMakeContextCurrent(window);

	// sets the swap interval for the current display context
	glfwSwapInterval(swapInterval);

#ifdef GLEW_VERSION
	// initialize GLEW library
	if (glewInit() != GLEW_OK)
	{
		cout << "failed to initialize GLEW library" << endl;
		glfwTerminate();
		return 1;
	}
#endif
	////////////////////////////////////////////////////////////////////////////////
	// WORLD - CAMERA - LIGHTING
	////////////////////////////////////////////////////////////////////////////////

	// create a new world.
	world = new cWorld();

	// set the background color of the environment
	world->m_backgroundColor.setBlack();

	// create a camera and insert it into the virtual world
	camera = new cCamera(world);
	world->addChild(camera);

	// position and orient the camera
	camera->set(cVector3d(0.5, 0.0, 0.0),    // camera position (eye)
		cVector3d(0.0, 0.0, 0.0),    // look at position (target)
		cVector3d(0.0, 0.0, 1.0));   // direction of the (up) vector

// set the near and far clipping planes of the camera
	camera->setClippingPlanes(0.02, 10.0);

	// set stereo mode
	camera->setStereoMode(stereoMode);

	// set stereo eye separation and focal length (applies only if stereo is enabled)
	camera->setStereoEyeSeparation(0.005);
	camera->setStereoFocalLength(0.5);

	// set vertical mirrored display mode
	camera->setMirrorVertical(mirroredDisplay);

	// create a directional light source
	light = new cDirectionalLight(world);

	// insert light source inside world
	world->addChild(light);

	// enable light source
	light->setEnabled(true);

	// define direction of light beam
	light->setDir(-1.0, 0.0, 0.0);

	// create a sphere (cursor) to represent the haptic device
	cursor = new cShapeTorus(0.02, 0.03);

	// insert cursor inside world
	world->addChild(cursor);

	// create small line to illustrate the velocity of the haptic device
	velocity = new cShapeLine(cVector3d(0, 0, 0), cVector3d(0, 0, 0));

	// insert line inside world
	world->addChild(velocity);
	////////////////////////////////////////////////////////////////////////////////
	// HAPTIC DEVICE
	////////////////////////////////////////////////////////////////////////////////

	// create a haptic device handler
	handler = new cHapticDeviceHandler();

	// get a handle to the first haptic device
	handler->getDevice(hapticDevice, 0);

	// open a connection with the haptic device
	hapticDevice->open();

	// retrieve information about the current haptic device
	cHapticDeviceInfo info = hapticDevice->getSpecifications();

	// if the device has a gripper, enable the gripper to behave like a user switch
	hapticDevice->setEnableGripperUserSwitch(true);


	////////////////////////////////////////////////////////////////////////////////
	// WIDGETS
	////////////////////////////////////////////////////////////////////////////////

	// create a font
	font = NEW_CFONTCALIBRI28();

	// create a label to display the haptic device model
	labelHapticDeviceModel = new cLabel(font);
	camera->m_frontLayer->addChild(labelHapticDeviceModel);
	labelHapticDeviceModel->setText(info.m_modelName);
	labelHapticDeviceModel->m_fontColor.setBlue();

	// create a label to display the position of haptic device
	labelHapticDevicePosition = new cLabel(font);
	camera->m_frontLayer->addChild(labelHapticDevicePosition);

	// create a label to display the haptic and graphic rate of the simulation
	labelRates = new cLabel(font);
	camera->m_frontLayer->addChild(labelRates);

	// create a scope(position scope) to plot haptic device position data
	scope0 = new cScope();
	camera->m_frontLayer->addChild(scope0);
	scope0->setLocalPos(800, 60);
	scope0->setRange(-.1, .1);
	scope0->setSignalEnabled(true);
	scope0->setTransparencyLevel(0.3);
	scope0->setSize(300, 350);
	//scope0->m_colorSignal2.setGreen();
	scope0->m_colorSignal0.setRed();
	//scope0->m_edgeLineColor.setRed();

	///////////Delay scope///////////////
	scope1 = new cScope();
	camera->m_frontLayer->addChild(scope1);
	scope1->setLocalPos(1177, 60);
	scope1->setRange(-0.1, 0.1);
	scope1->setSignalEnabled(true, true);
	scope1->setTransparencyLevel(0.3);
	scope1->setSize(300, 350);
	scope1->m_colorSignal2.setGreen();
	scope1->m_colorSignal0.setRed();

	//////////////Force scope//////////////
	scope2 = new cScope();
	camera->m_frontLayer->addChild(scope2);
	scope2->setLocalPos(1550, 60);
	scope2->setRange(-0.1, 0.1);
	scope2->setSignalEnabled(true, true);
	scope2->setTransparencyLevel(0.3);
	scope2->setSize(300, 350);
	scope2->m_colorSignal2.setGreen();
	scope2->m_colorSignal0.setRed();


	scope3 = new cScope();
	camera->m_frontLayer->addChild(scope3);
	scope3->setLocalPos(800, 450);
	scope3->setRange(-10, 10);
	scope3->setSignalEnabled(true, true);
	scope3->setTransparencyLevel(0.3);
	scope3->setSize(300, 350);
	scope3->m_colorSignal2.setGreen();
	scope3->m_colorSignal0.setRed();



	scope4 = new cScope();
	camera->m_frontLayer->addChild(scope4);
	scope4->setLocalPos(1177, 450);
	scope4->setRange(-10, 10);
	scope4->setSignalEnabled(true, true);
	scope4->setTransparencyLevel(0.3);
	scope4->setSize(300, 350);
	scope4->m_colorSignal2.setGreen();
	scope4->m_colorSignal0.setRed();

	scope5 = new cScope();
	camera->m_frontLayer->addChild(scope5);
	scope5->setLocalPos(1550, 450);
	scope5->setRange(-10, 10);
	scope5->setSignalEnabled(true, true);
	scope5->setTransparencyLevel(0.3);
	scope5->setSize(300, 350);
	scope5->m_colorSignal2.setGreen();
	scope5->m_colorSignal0.setRed();
	//scope5->

	// create a level to display velocity data

	leveldelay = new cLevel();
	camera->m_frontLayer->addChild(leveldelay);
	leveldelay->setLocalPos(60, 60);
	leveldelay->setRange(0.0, 200);
	leveldelay->setWidth(40);
	leveldelay->setNumIncrements(50);
	leveldelay->setSingleIncrementDisplay(false);
	leveldelay->setTransparencyLevel(0.7);

	//double getRangeMax(delay);
	Server2 = Server.substr(0, 14);
	//cout << Server2;
	if (Server2 == "192.168.4.3") {
		//Range = 15;
		labelMax = new cLabel(font);
		camera->m_frontLayer->addChild(labelMax);
		labelMax->setText("Teleoperation running over WAN");
		labelMax->setLocalPos(20, height - 220);
		labelMax->m_fontColor.setWhite();
	}
	else if (Server2 == "172") {
		//Range = 20;
		labelMax = new cLabel(font);
		camera->m_frontLayer->addChild(labelMax);
		labelMax->setText("Teleoperation running over LAN");
		labelMax->setLocalPos(20, height - 220);
		labelMax->m_fontColor.setWhite();
	}

	else if (Server2 == "127") {
		//Range = 20;
		labelMax = new cLabel(font);
		camera->m_frontLayer->addChild(labelMax);
		labelMax->setText("Teleoperation running over LAN");
		labelMax->setLocalPos(20, height - 220);
		labelMax->m_fontColor.setWhite();
	}
	else {
		//Range = 700;
		labelMax = new cLabel(font);
		camera->m_frontLayer->addChild(labelMax);
		labelMax->setText("Teleoperation running over LAN");
		labelMax->setLocalPos(20, height - 220);
	}

	////position scope ranges
	//labelMax = new cLabel(font);
	//camera->m_frontLayer->addChild(labelMax);
	//labelMax->setText("-0.1");
	//labelMax->setLocalPos(110, 60);

	/////////////updated_scopes info////////////////
	/////force_scopes/////////////

	scopename = new cLabel(font);
	camera->m_frontLayer->addChild(scopename);
	scopename->setText("Forces(z)");
	scopename->setLocalPos(1550, 500);


	scopename = new cLabel(font);
	camera->m_frontLayer->addChild(scopename);
	scopename->setText("-10");
	scopename->setLocalPos(1520, 480);

	scopename = new cLabel(font);
	camera->m_frontLayer->addChild(scopename);
	scopename->setText("10");
	scopename->setLocalPos(1520, 750);

	scopename = new cLabel(font);
	camera->m_frontLayer->addChild(scopename);
	scopename->setText("Forces(y)");
	scopename->setLocalPos(1177, 500);

	scopename = new cLabel(font);
	camera->m_frontLayer->addChild(scopename);
	scopename->setText("-10");
	scopename->setLocalPos(1147, 480);

	scopename = new cLabel(font);
	camera->m_frontLayer->addChild(scopename);
	scopename->setText("10");
	scopename->setLocalPos(1147, 750);


	scopename = new cLabel(font);
	camera->m_frontLayer->addChild(scopename);
	scopename->setText("Server Pos(x)");
	scopename->setLocalPos(800, 500);

	scopename = new cLabel(font);
	camera->m_frontLayer->addChild(scopename);
	scopename->setText("-10");
	scopename->setLocalPos(770, 480);

	scopename = new cLabel(font);
	camera->m_frontLayer->addChild(scopename);
	scopename->setText("10");
	scopename->setLocalPos(770, 750);

	/////////position_scope//////////
	///////////////////////////////////////
	scopename = new cLabel(font);
	camera->m_frontLayer->addChild(scopename);
	scopename->setText("Xm(z)");
	scopename->setLocalPos(1550, 60);

	scopename = new cLabel(font);
	camera->m_frontLayer->addChild(scopename);
	scopename->setText("-0.1");
	scopename->setLocalPos(1520, 100);

	scopename = new cLabel(font);
	camera->m_frontLayer->addChild(scopename);
	scopename->setText("0.1");
	scopename->setLocalPos(1520, 360);
	///////////////////////////////
	scopename = new cLabel(font);
	camera->m_frontLayer->addChild(scopename);
	scopename->setText("Xm(y)");
	scopename->setLocalPos(1177, 60);

	scopename = new cLabel(font);
	camera->m_frontLayer->addChild(scopename);
	scopename->setText("-0.1");
	scopename->setLocalPos(1147, 100);

	scopename = new cLabel(font);
	camera->m_frontLayer->addChild(scopename);
	scopename->setText("0.1");
	scopename->setLocalPos(1147, 360);
	////////////////////////////////
	scopename = new cLabel(font);
	camera->m_frontLayer->addChild(scopename);
	scopename->setText("Xm(x)");
	scopename->setLocalPos(800, 60);
	scopename = new cLabel(font);
	camera->m_frontLayer->addChild(scopename);
	scopename->setText("-0.1");
	scopename->setLocalPos(770, 100);

	scopename = new cLabel(font);
	camera->m_frontLayer->addChild(scopename);
	scopename->setText("0.1");
	scopename->setLocalPos(770, 360);

	////////////////////////////////////////////////

	//labelMin = new cLabel(font);
	//camera->m_frontLayer->addChild(labelMin);
	//labelMin->setText(" 0.1");
	//labelMin->setLocalPos(110, 220);


	labelXd_Prev = new cLabel(font);
	labelXd = new cLabel(font);
	labelX_Recv = new cLabel(font);
	labelFd = new cLabel(font);
	labelSlave_force = new cLabel(font);
	labeldFe = new cLabel(font);
	labelIP = new cLabel(font);
	labelProjFOR = new cLabel(font);
	labelDelay = new cLabel(font);
	labelc1 = new cLabel(font);
	labelc2 = new cLabel(font);
	labelbuff = new cLabel(font);

	camera->m_frontLayer->addChild(labelXd_Prev);
	camera->m_frontLayer->addChild(labelXd);
	camera->m_frontLayer->addChild(labelX_Recv);
	camera->m_frontLayer->addChild(labelFd);
	camera->m_frontLayer->addChild(labelSlave_force);
	camera->m_frontLayer->addChild(labeldFe);
	camera->m_frontLayer->addChild(labelIP);
	camera->m_frontLayer->addChild(labelProjFOR);
	camera->m_frontLayer->addChild(labelDelay);
	camera->m_frontLayer->addChild(labelc1);
	camera->m_frontLayer->addChild(labelc2);
	camera->m_frontLayer->addChild(labelbuff);

	labelIP->setText("Server IP: ");
	labelIP->setLocalPos(20, height - 60);
	labelIP->m_fontColor.setBlueLight();


	//labelXd_Prev->setText("Prev Xd: ");
	//labelXd_Prev->setLocalPos(20, height - 80);
	//labelXd_Prev->m_fontColor.setGreenLight();

	labelXd->setText("Master Pos: ");
	labelXd->setLocalPos(20, height - 100);
	labelXd->m_fontColor.setOrange();

	labelX_Recv->setText("Slave Pos:   ");
	labelX_Recv->setLocalPos(20, height - 120);
	labelX_Recv->m_fontColor.setGreen();


	labelFd->setText("Master Force: ");
	labelFd->setLocalPos(20, height - 140);
	labelFd->m_fontColor.setRed();

	labelSlave_force->setText("Slave Force: ");
	labelSlave_force->setLocalPos(20, height - 160);
	labelSlave_force->m_fontColor.setBlueLight();

	labeldFe->setText("EBA Force: ");
	labeldFe->setLocalPos(20, height - 180);
	labeldFe->m_fontColor.setWhite();

	labelProjFOR->setText("ProjFOR: ");
	labelProjFOR->setLocalPos(20, height - 200);
	labelProjFOR->m_fontColor.setPink();

	labelRates->setText("Frequency: ");
	labelRates->setLocalPos(100, height - 160);
	labelRates->m_fontColor.setWhite();

	labelDelay->setText("Delay: ");
	labelDelay->setLocalPos(width - 845, height - 220);
	labelDelay->m_fontColor.setGray();

	labelc1->setText("c1 : ");
	labelc1->setLocalPos(width - 845, height - 240);
	labelc1->m_fontColor.setGray();

	labelc2->setText("c2 : ");
	labelc2->setLocalPos(width - 845, height - 260);
	labelc2->m_fontColor.setGray();
	//////////////////////////////////
	/*labelbuff->setText("buffer : ");
	labelbuff->setLocalPos(width - 845, height - 280);
	labelbuff->m_fontColor.setGray();*/
	////////////////////////////////////////////////////////////////////////////////
	// START SIMULATION
	////////////////////////////////////////////////////////////////////////////////
	// create a thread which starts the main haptics rendering loop
	hapticsThread = new cThread();
	hapticsThread->start(updateHaptics, CTHREAD_PRIORITY_HAPTICS);

	// setup callback when application exits
	atexit(close);
	////////////////////////////////////////////////////////////////////////////////
	// MAIN GRAPHIC LOOP
	////////////////////////////////////////////////////////////////////////////////

	// call window size callback at initialization
	windowSizeCallback(window, width, height);

	while (!glfwWindowShouldClose(window))
	{
		// get width and height of window
		glfwGetWindowSize(window, &width, &height);

		// render graphics
		updateGraphics();

		// swap buffers
		glfwSwapBuffers(window);

		// process events
		glfwPollEvents();

		// signal frequency counter
		freqCounterGraphics.signal(1);
	}

	// close window
	glfwDestroyWindow(window);

	// terminate GLFW library
	glfwTerminate();

	// exit
	return (0);
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void updateGraphics(void)
{

	/////////////////////////////////////////////////////////////////////
	// UPDATE WIDGETS
	/////////////////////////////////////////////////////////////////////

	// update position data
	labelHapticDevicePosition->setText(hapticDevicePosition.str(3));

	// update haptic and graphic rate data
	labelRates->setText(cStr(freqCounterGraphics.getFrequency(), 0) + " Hz / " +
		cStr(freqCounterHaptics.getFrequency(), 0) + " Hz");

	// update position of label
	labelRates->setLocalPos((int)(0.5 * (width - labelRates->getWidth())), 15);


	// update information to scope
	scope0->setSignalValues(hapticDevicePosition.y());
	scope3->setSignalValues(ReadData[1]);
	/*scope2->setSignalValues(hapticDevicePosition.z(), ReadData[5]);
	scope3->setSignalValues(ProjFOR[0], -ReadData[0]);
	scope4->setSignalValues(ProjFOR[1], -ReadData[1]);
	scope5->setSignalValues(ProjFOR[2], -ReadData[2]);*/
	leveldelay->setValue(TAP);

	labelIP->setText("Client IP: " + string(inet_ntoa(clientaddr.sin_addr)) + ":" + cStr(ntohs(clientaddr.sin_port)));

	labelXd->setText("Master Pos: " + cStr(pos_curr[0], 3U) + "  " + cStr(pos_curr[1], 3U) + "  " + cStr(pos_curr[2], 3U));
	labelX_Recv->setText("Slave Pos:     " + cStr(pos_recv[0], 3U) + "  " + cStr(pos_recv[1], 3U) + "  " + cStr(pos_recv[2], 3U));
	labelFd->setText("Master force: " + cStr(Fd[0], 3U) + "  " + cStr(Fd[1], 3U) + "  " + cStr(Fd[2], 3U));
	labelSlave_force->setText("Slave force:    " + cStr(-ReadData[0], 3U) + "  " + cStr(-ReadData[1], 3U) + "  " + cStr(-ReadData[2], 3U));
	labeldFe->setText("EBA force: " + cStr(dFe[0], 3U) + "  " + cStr(dFe[1], 3U) + "  " + cStr(dFe[2], 3U));
	labelProjFOR->setText("Projected force: " + cStr(ProjFOR[0], 3U) + "  " + cStr(ProjFOR[1], 3U) + "  " + cStr(ProjFOR[2], 3U));
	labelDelay->setText("Delay: " + cStr(abs(delay), 3U) + "ms");
	labelc1->setText("c1: " + cStr(abs(c1), 3U));
	labelc2->setText("c2: " + cStr(abs(c2), 3U));
	//labelbuff->setText("buffer data " + cStr(rbuf));
	/////////////////////////////////////////////////////////////////////
	// RENDER SCENE
	/////////////////////////////////////////////////////////////////////

	// update shadow maps (if any)
	world->updateShadowMaps(false, mirroredDisplay);

	// render world
	camera->renderView(width, height);

	// wait until all OpenGL commands are completed
	glFinish();

	// check for any OpenGL errors
	GLenum err;
	err = glGetError();
	if (err != GL_NO_ERROR) cout << "Error:  %s\n" << gluErrorString(err);
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void updateHaptics(void)
{
	// simulation in now running
	simulationRunning = true;
	simulationFinished = false;

	// main haptic simulation loop
	while (simulationRunning)
	{
		/////////////////////////////////////////////////////////////////////
		// READ HAPTIC DEVICE
		/////////////////////////////////////////////////////////////////////

		// read position 
		cVector3d position;
		hapticDevice->getPosition(position);
		//cout <<"position " <<position<<endl;

		// read linear velocity 
		cVector3d linearVelocity;
		hapticDevice->getLinearVelocity(linearVelocity);

		// read user-switch status (button 0)
		bool button0, button1, button2, button3;

		button0 = false;
		button1 = false;
		button2 = false;
		button3 = false;

		hapticDevice->getUserSwitch(0, button0);
		hapticDevice->getUserSwitch(1, button1);
		hapticDevice->getUserSwitch(2, button2);
		hapticDevice->getUserSwitch(3, button3);


		/////////////////////////////////////////////////////////////////////
		// UPDATE 3D CURSOR MODEL
		/////////////////////////////////////////////////////////////////////

		// update arrow
		velocity->m_pointA = position;
		velocity->m_pointB = cAdd(position, linearVelocity);

		// update position and orientation of cursor
		cursor->setLocalPos(position);

		// adjust the  color of the cursor according to the status of
		// the user-switch (ON = TRUE / OFF = FALSE)
		if (button0)
		{
			cursor->m_material->setGreenMediumAquamarine();

			for (int G = 0; G >= 0; G++)
			{
				TAP = 0;
				c1 = 100;
				break;
			}
		}
		else if (button1)
		{
			cursor->m_material->setYellowGold();
			for (int G = 0; G >= 0; G++)
			{
				TAP = TAP - 1;
				//cout << TAP;
				if (TAP == -1 && -2 && -3 && -4 && -5 && -6 && -7 && -8 && -9)
				{
					TAP = 0;
				}

				break;
			}
		}
		else if (button2)
		{
			cursor->m_material->setOrangeCoral();

			{
				for (int h = 1; h > 0; h++)
				{
					c1 += .1;
					break;
				}
			}
			//for (int C = 0; C >= 0; C++)
			//{
			//	c2 = c2 + 5;
			//	//cout << TAP;
			//	break;
			//}
		}
		else if (button3)
		{
			cursor->m_material->setPurpleLavender();
			for (int C = 0; C >= 0; C++)
			{
				TAP = TAP + 1;
				//cout << TAP;
				break;
			}
		}
		else
		{
			cursor->m_material->setBlueRoyal();
		}

		// update global variable for graphic display update
		hapticDevicePosition = position;
		hapticDeviceVelocity = linearVelocity;


		/////////////////////////////////////////////////////////////////////
		// COMPUTE AND APPLY FORCES
		/////////////////////////////////////////////////////////////////////
		for (int i = 1; i < 2; i++)
		{
			pos_curr[i] = hapticDevicePosition(i);
		}

		// µ¥ÀÌÅÍ ¹Þ±â
		UDPReadData();
		Fd[1] = ReadData[1];

		//Sleep(delay+1);

		// Output data to the buffer
		string data = sbuf;
		memcpy(buffer, data.c_str(), data.size() + 1);
		//cout << buffer << endl;

		SendData[1] = pos_curr[1];
		UDPSendData(SendData);

		//timestamp1 = ReadData[3];
	
		//SendData[3] = timestamp1;

		//cout << timeUDPRr << endl;

		cVector3d force(0, 0, 0);

		double gripperForce = 0.0;

		// apply force field
		if (useForceField)
		{
			// compute linear force
			double Kp = c2;
			//25; // [N/m]
			cVector3d forceField = -Kp * position;
			force.add(forceField);

			for (int i = 1; i < 2; i++)
			{
				//Fd[i] = Kp * (pos_recv[i] - pos_curr[i]);
				//force(i) = Fd[i];
				pos_prev[i] = pos_curr[i];
				//cout << "Fd " << Fd[i] << endl;
				//cSleepMs(TAP);


				XdP[i] = Xd[i];
				//cout << "XdP is  " << XdP[i] << endl;
				Xd[i] = pos_curr[i];
				//cout << "Xd      " << Xd[i] << endl;
				//DXd[2] = Xd[2] - XdP[2]+1;
				DXd[i] = Xd[i] - XdP[i];
				//	cout << "DXd is " << DXd[i] << endl;

			}

			//apply EBA


			if (EnableEBA)
			{
				for (int i = 1; i < 2; i++)
				{
					if (DXd[i] != 0)
					{
						//cout << "XdP is" << XdP << endl;
						//cout << "EBA DXd is " << DXd[i] << endl;


						//cout << "DXd222  " << endl;// Control law
						// Calculation of Beta
						uBETA[i] = BETA[i] = (Fd[i] - dFe[i]) / DXd[i];

						// Calculation of Gamma_max & Gamma_min
						Bmax[i] = c2 - dFe[i] / DXd[i] + sqrt(dFe[i] * dFe[i] / DXd[i] / DXd[i] + c2 * c2); //Gamma_max
						Bmin[i] = c2 - dFe[i] / DXd[i] - sqrt(dFe[i] * dFe[i] / DXd[i] / DXd[i] + c2 * c2); //Gamma_min

						if (Bmax[i] > c1)
							Bmax[i] = c1; // min(c1, Gamma_max)

						// Bounding Law
						if (BETA[i] < Bmin[i])
							BETA[i] = Bmin[i];
						if (BETA[i] > Bmax[i])
							BETA[i] = Bmax[i];


					}
					else
					{
						//cout << "beta_else is running" << endl;
						uBETA[i] = BETA[i];
						BETA[i] = BETA[i];
					}

					dFe[i] = dFe[i] + BETA[i] * DXd[i];

					if (nProjection)
					{
						////////////// Projection method //////////////

						FOR_Mag = sqrt(Fd[0] * Fd[0] + Fd[1] * Fd[1] + Fd[2] * Fd[2]);

						if (fabs(FOR_Mag) > 0.0)				// fabs(Fmag) > 0.0 is used instead of FeMag != 0.0 because 0.0 looks ZERO but it can be 0.000000000000000000000000000000XXX
						//if(FOR_Mag != 0.0)
						{
							UnitV[i] = Fd[i] / FOR_Mag;	// Unit Vector
						}
						else
						{
							UnitV[i] = 0.0;
						}

						// Inner Product
						InnerProduct = dFe[0] * UnitV[0] + dFe[1] * UnitV[1] + dFe[2] * UnitV[2];	// Inner Product

						ProjFOR[i] = InnerProduct * UnitV[i];
						force(i) = -ProjFOR[i];
					}

				}
			}

			else
			{
				for (int i = 1; i < 2; i++)
				{
					cout << "else is running" << endl;
					dFe[i] = Fd[i];
					force(i) = -dFe[i];

				}
			}
		}
		// send computed force



			

		/*	return 0;
		}*/

		// Pause for 1 second
		
		

		hapticDevice->setForce(force);
		// update frequency counter
		freqCounterHaptics.signal(1);
	}
	
	// exit haptics thread
	simulationFinished = true;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void windowSizeCallback(GLFWwindow* a_window, int a_width, int a_height)
{
	// update window size
	width = a_width;
	height = a_height;

	// update position of label
	labelHapticDevicePosition->setLocalPos(20, width - 60, 0);

	// update position of label
	labelHapticDeviceModel->setLocalPos(20, height - 40, 0);


	labelIP->setLocalPos(20, height - 60);
	labelMax->setLocalPos(20, height - 80);
	labelXd->setLocalPos(20, height - 120);
	labelX_Recv->setLocalPos(20, height - 140);
	labelFd->setLocalPos(20, height - 180);
	labelSlave_force->setLocalPos(20, height - 200);
	labeldFe->setLocalPos(20, height - 240);
	labelProjFOR->setLocalPos(20, height - 260);
	// update position of scope
	//scope0->setSize(200, 180);
	//scope1->setSize(200, 360);
	//scope2->setSize(200, 540);
	//scope3->setSize(400, 180);
	//scope4->setSize(600, 180);
	//scope5->setSize(800, 180);
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void errorCallback(int a_error, const char* a_description)
{
	cout << "Error: " << a_description << endl;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void keyCallback(GLFWwindow* a_window, int a_key, int a_scancode, int a_action, int a_mods)
{
	// filter calls that only include a key press
	if ((a_action != GLFW_PRESS) && (a_action != GLFW_REPEAT))
	{
		return;
	}

	// option - exit
	if ((a_key == GLFW_KEY_ESCAPE) || (a_key == GLFW_KEY_Q))
	{
		glfwSetWindowShouldClose(a_window, GLFW_TRUE);
	}

	// option - enable/disable force field
	if (a_key == GLFW_KEY_1)
	{
		useForceField = !useForceField;
		if (useForceField)
			cout << "> Enable force field     \r";
		else
			cout << "> Disable force field    \r";
	}

	if (a_key == GLFW_KEY_M)
	{
		mirroredDisplay = !mirroredDisplay;
		camera->setMirrorHorizontal(mirroredDisplay);

	}
	if (a_key == GLFW_KEY_F)
	{
		// toggle state variable
		fullscreen = !fullscreen;

		// get handle to monitor
		GLFWmonitor* monitor = glfwGetPrimaryMonitor();

		// get information about monitor
		const GLFWvidmode* mode = glfwGetVideoMode(monitor);

		// set fullscreen or window mode
		if (fullscreen)
		{
			glfwSetWindowMonitor(window, monitor, 0, 0, mode->width, mode->height, mode->refreshRate);
			glfwSwapInterval(swapInterval);
		}
		else
		{
			int w = 0.8 * mode->height;
			int h = 0.5 * mode->height;
			int x = 0.5 * (mode->width - w);
			int y = 0.5 * (mode->height - h);
			glfwSetWindowMonitor(window, NULL, x, y, w, h, mode->refreshRate);
			glfwSwapInterval(swapInterval);
		}
	}
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void close(void)
{
	CloseUDP();
	// stop the simulation
	simulationRunning = false;

	// wait for graphics and haptics loops to terminate
	while (!simulationFinished)
	{
		cSleepMs(100);
	}

	// close haptic device
	hapticDevice->close();

	// delete resources
	delete hapticsThread;
	delete world;
	delete handler;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void InitUDP()
{
	// À©¼Ó ÃÊ±âÈ­
	if (WSAStartup(MAKEWORD(2, 2), &wsa) != 0)
	{
		MessageBox(NULL, "Socket Open Error!!", "UDP", MB_OK);
	}


	// socket()
	sock = socket(AF_INET, SOCK_DGRAM, 0);
	if (sock == INVALID_SOCKET)
	{
		err_quit("socket()");
	}

	// bind()
	ZeroMemory(&serveraddr, sizeof(serveraddr));
	serveraddr.sin_family = AF_INET;
	serveraddr.sin_port = htons(UDP_PORT);
	serveraddr.sin_addr.s_addr = inet_addr(SERVER_IP);
	retval = ::bind(sock, (SOCKADDR*)&serveraddr, sizeof(serveraddr));

}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void UDPSendData(float sData[SENDDATA_NUM])
{
	//	sprintf(sbuf, "%f %f %f %f %f %f %f %f %f %f %f %f %f %f %f %f %f %f %f %f", sData[0], sData[1], sData[2], sData[3], sData[4], sData[5], sData[6], sData[7], sData[8], sData[9], sData[10], sData[11], sData[12], sData[13], sData[14], sData[15], sData[16], sData[17], sData[18], sData[19]);
	Timer time;
	sprintf(sbuf, "%f", sData[1]);
	retval = sendto(sock, sbuf, strlen(sbuf), 0, (SOCKADDR*)&clientaddr, sizeof(clientaddr));
	//cout << sbuf << endl;
	if (retval == SOCKET_ERROR)
	{
		err_display("sendto()");
		exit(-1);
	}
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void UDPReadData()
{
	Timer2 time;
	addrlen = sizeof(clientaddr);
	retval = recvfrom(sock, rbuf, BUFSIZE, 0, (SOCKADDR*)&clientaddr, &addrlen);
	if (retval == SOCKET_ERROR)
	{
		err_display("recvfrom()");
		exit(-1);
	}
	delay = timeUDPS - timeUDPR;
	countd = countd++;
	cSleepMs(TAP);
	//	sscanf(rbuf, "%f %f %f %f %f %f %f %f %f %f %f %f %f %f %f %f %f %f %f %f", &ReadData[0], &ReadData[1], &ReadData[2], &ReadData[3], &ReadData[4], &ReadData[5], &ReadData[6], &ReadData[7], &ReadData[8], &ReadData[9], &ReadData[10], &ReadData[11], &ReadData[12], &ReadData[13], &ReadData[14], &ReadData[15], &ReadData[16], &ReadData[17], &ReadData[18], &ReadData[19]);
	sscanf(rbuf, "%f", &ReadData[1]);
}

void Adap_buffer()
{
	// Fill the buffer with some data
	for (int i = 0; i < BUFFER_SIZE; i++)
	{
		//buffer[i] = 'A';
	}

	// Start a loop to output the contents of the buffer at regular intervals
	while (true)
	{
		// Measure the elapsed time
		clock_t startTime = clock();
		while ((clock() - startTime) / CLOCKS_PER_SEC < OUTPUT_INTERVAL_SECONDS)
		{
			// Do nothing
		}

		// Output the contents of the buffer
		for (int i = 0; i < BUFFER_SIZE; i++)
		{
			//cout << buffer[i];
		}
		//std::cout << std::endl;
	}
}




int Adap_buffer2()
{
	char buffer[BUFFER_SIZE];

	// Pause for 1 second
	Sleep(delay);

	// Output data to the buffer
	string data = sbuf;
	memcpy(buffer, data.c_str(), data.size() + 1);
	cout << buffer << endl;

	return 0;
}
void CloseUDP()
{
	// closesocket()
	closesocket(sock);
	// À©¼Ó Á¾·á
	WSACleanup();
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// ¼ÒÄÏ ÇÔ¼ö ¿À·ù Ãâ·  ÈÄ Á¾·á
void err_quit(const char* msg)
{
	LPVOID lpMsgBuf;

	FormatMessage(
		FORMAT_MESSAGE_ALLOCATE_BUFFER |
		FORMAT_MESSAGE_FROM_SYSTEM,
		NULL, WSAGetLastError(),
		MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),

		(LPTSTR)&lpMsgBuf, 0, NULL);
	MessageBox(NULL, (LPCTSTR)lpMsgBuf, msg, MB_ICONERROR);
	LocalFree(lpMsgBuf);
	exit(-1);
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// ¼ÒÄÏ ÇÔ¼ö ¿À·ù Ãâ·Â
void err_display(const char* msg)
{
	LPVOID lpMsgBuf;
	FormatMessage(
		FORMAT_MESSAGE_ALLOCATE_BUFFER |
		FORMAT_MESSAGE_FROM_SYSTEM,
		NULL, WSAGetLastError(),
		MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
		(LPTSTR)&lpMsgBuf, 0, NULL);

	printf("[%s] %s", msg, (LPCTSTR)lpMsgBuf);
	LocalFree(lpMsgBuf);
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#include <winsock2.h>
#include <stdlib.h>
#include <stdio.h>
#include <fstream>
#include "chai3d.h"
#include <GLFW/glfw3.h>
#include <time.h>
#include <chrono>
#include <dos.h>
//#include<E:\NCRA Lab Dr Riazuddin\Telepresence client\HandShake_Chai3d_server\src\koolplot.h>
#pragma comment(lib, "ws2_32.lib")

////////////////////////////////////////////////////////////////////////////////
using namespace chai3d;
using namespace std;


////////////////////////////////////////////////////////////////////////////////
// Device Param.
////////////////////////////////////////////////////////////////////////////////
#define DOF 3

double pos_curr[DOF] = { 0, 0, 0 };
double pos_prev[DOF] = { 0, 0, 0 };
double pos_recv[DOF] = { 0, 0, 0 };
double Fd[DOF];
int d;
int f;
int countd = 0;
////////////////////////////////////////////////////////////////////////////////
// UDP Param.
////////////////////////////////////////////////////////////////////////////////
#define BUFSIZE 4096
#define SERVER_IP "188.72.116.145" // "127.0.0.1" // "111.68.110.189"  "203.237.55.14"\\lithuania
#define UDP_PORT 4000
#define SENDDATA_NUM 4
#define READDATA_NUM 4


int retval;
WSADATA wsa;

SOCKET sock;

// µ¥ÀÌÅÍ Åë½Å¿¡ »ç¿ëÇÒ º¯¼ö
SOCKADDR_IN serveraddr;
SOCKADDR_IN clientaddr;

int addrlen;
char sbuf[BUFSIZE + 1], rbuf[BUFSIZE + 1];
int timeUDPR;
int timeUDPS;
double  delay(1000);


float SendData[SENDDATA_NUM], ReadData[READDATA_NUM];

bool isFirstRecv = false;
struct Timer
{
	chrono::time_point<std::chrono::steady_clock>start, end;
	chrono::duration<float>duration;
	Timer()
	{
		start = std::chrono::high_resolution_clock::now();

	}
	~Timer()
	{
		end = std::chrono::high_resolution_clock::now();
		duration = end - start;
		float ms = duration.count() * 1000.0f;
		timeUDPR = ms;
		//cout << "Timer took" << ms << "ms" << endl;

	}
};
struct Timer2
{
	chrono::time_point<std::chrono::steady_clock>start, end;
	chrono::duration<float>duration;
	Timer2()
	{
		start = std::chrono::high_resolution_clock::now();

	}
	~Timer2()
	{
		end = std::chrono::high_resolution_clock::now();
		duration = end - start;
		float ms = duration.count() * 1000.0f;
		timeUDPS = ms;
		//cout << "Timer took" << ms << "ms" << endl;

	}
};
////////////////////////////////////////////////////////////////////////////////
// Delay Param.
////////////////////////////////////////////////////////////////////////////////
#define DELAY 1
#define DELAYDATA_NUM 3

double ClientData[DELAYDATA_NUM];
double DelayDataBuf[DELAYDATA_NUM][DELAY];
double DelayData[DELAYDATA_NUM];
//double delay[DELAY] = { 0 };

////////////////////////////////////////////////////////////////////////////////
// GUI - GENERAL SETTINGS
////////////////////////////////////////////////////////////////////////////////

// stereo Mode
/*
	C_STEREO_DISABLED:            Stereo is disabled
	C_STEREO_ACTIVE:              Active stereo for OpenGL NVDIA QUADRO cards
	C_STEREO_PASSIVE_LEFT_RIGHT:  Passive stereo where L/R images are rendered next to each other
	C_STEREO_PASSIVE_TOP_BOTTOM:  Passive stereo where L/R images are rendered above each other
*/
cStereoMode stereoMode = C_STEREO_DISABLED;

// fullscreen mode
bool fullscreen = false;
// a flag for using damping (ON/OFF)
bool useDamping = false;
// mirrored display
bool mirroredDisplay = false;



////////////////////////////////////////////////////////////////////////////////
// GUI - DECLARED VARIABLES
////////////////////////////////////////////////////////////////////////////////

// a world that contains all objects of the virtual environment
cWorld* world;

// a camera to render the world in the window display
cCamera* camera;

// a light source to illuminate the objects in the world
cDirectionalLight* light;

// a haptic device handler
cHapticDeviceHandler* handler;

// a pointer to the current haptic device
cGenericHapticDevicePtr hapticDevice;

// a label to display the haptic device model
cLabel* labelHapticDeviceModel;

// a label to display the position [m] of the haptic device
cLabel* labelHapticDevicePosition;

// a global variable to store the position [m] of the haptic device
cVector3d hapticDevicePosition;

// a global variable to store the velocity [m/s] of the haptic device
cVector3d hapticDeviceVelocity;

// a font for rendering text
cFontPtr font;

// a label to display the rate [Hz] at which the simulation is running
cLabel* labelRates;

cLabel* labelMax;
cLabel* labelMin;

cLabel* labelXd;
cLabel* labelXd_Prev;

cLabel* labelX_Recv;
cLabel* labelFd;

cLabel* labelIP;
cLabel* labelDelay;

// a small sphere (cursor) representing the haptic device 
cShapeTorus* cursor;

// a line representing the velocity of the haptic device
cShapeLine* velocity;

// a scope to monitor position values of haptic device
cScope* scope;
// read linear velocity 
cVector3d linearVelocity;


// a flag for using force field (ON/OFF)
bool useForceField = true;

// a flag to indicate if the haptic simulation currently running
bool simulationRunning = false;

// a flag to indicate if the haptic simulation has terminated
bool simulationFinished = true;

// a frequency counter to measure the simulation graphic rate
cFrequencyCounter freqCounterGraphics;

// a frequency counter to measure the simulation haptic rate
cFrequencyCounter freqCounterHaptics;

// haptic thread
cThread* hapticsThread;

// a handle to window display context
GLFWwindow* window = NULL;

// current width of window
int width = 0;

// current height of window
int height = 0;

// swap interval for the display context (vertical synchronization)
int swapInterval = 1;


////////////////////////////////////////////////////////////////////////////////
// GUI - DECLARED FUNCTIONS
////////////////////////////////////////////////////////////////////////////////

// callback when the window display is resized
void windowSizeCallback(GLFWwindow* a_window, int a_width, int a_height);

// callback when an error GLFW occurs
void errorCallback(int error, const char* a_description);

// callback when a key is pressed
void keyCallback(GLFWwindow* a_window, int a_key, int a_scancode, int a_action, int a_mods);

// this function renders the scene
void updateGraphics(void);

// this function contains the main haptics simulation loop
void updateHaptics(void);

// this function closes the application
void close(void);

void InitUDP(void);
void modifiedEBA(void);
void CloseUDP();
void UDPSendData(float sData[SENDDATA_NUM]);
void UDPReadData();
void err_quit(const char* msg);
void err_display(const char* msg);

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////





////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int main(int argc, char* argv[])
{
	InitUDP();

	////////////////////////////////////////////////////////////////////////////////
	// INITIALIZATION
	////////////////////////////////////////////////////////////////////////////////

	cout << endl;
	cout << "-----------------------------------" << endl;
	cout << "Dr. Riazuddin Teleoperation (SERVER)" << endl;
	cout << "-----------------------------------" << endl << endl << endl;
	cout << "Keyboard Options:" << endl << endl;
	cout << "[1] - Enable/Disable potential field" << endl;
	cout << "[f] - toggle fullscreen" << endl;
	cout << "[M] - Mirrored Display" << endl;
	cout << "[q] - Exit application" << endl;
	cout << " " << endl;
	cout << "********************" << endl;

	////////////////////////////////////////////////////////////////////////////////
	// OPEN GL - WINDOW DISPLAY
	////////////////////////////////////////////////////////////////////////////////

	if (!glfwInit())
	{
		cout << "failed initialization" << endl;
		cSleepMs(1000);
		return 1;
	}

	// set error callback
	glfwSetErrorCallback(errorCallback);

	// compute desired size of window
	const GLFWvidmode* mode = glfwGetVideoMode(glfwGetPrimaryMonitor());
	int w = 1 * mode->height;
	int h = 0.7 * mode->height;
	int x = 0.7 * (mode->width - w);
	int y = 0.7 * (mode->height - h);


	// set OpenGL version
	glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 2);
	glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 1);

	// set active stereo mode
	if (stereoMode == C_STEREO_ACTIVE)
	{
		glfwWindowHint(GLFW_STEREO, GL_TRUE);
	}
	else
	{
		glfwWindowHint(GLFW_STEREO, GL_FALSE);
	}

	// create display context
	window = glfwCreateWindow(w, h, "Dr. Riazuddin Teleoperation (SERVER)", NULL, NULL);
	if (!window)
	{
		cout << "failed to create window" << endl;
		cSleepMs(1000);
		glfwTerminate();
		return 1;
	}

	// get width and height of window
	glfwGetWindowSize(window, &width, &height);

	// set position of window
	glfwSetWindowPos(window, x, y);

	// set key callback
	glfwSetKeyCallback(window, keyCallback);

	// set resize callback
	glfwSetWindowSizeCallback(window, windowSizeCallback);

	// set current display context
	glfwMakeContextCurrent(window);

	// sets the swap interval for the current display context
	glfwSwapInterval(swapInterval);

#ifdef GLEW_VERSION
	// initialize GLEW library
	if (glewInit() != GLEW_OK)
	{
		cout << "failed to initialize GLEW library" << endl;
		glfwTerminate();
		return 1;
	}
#endif


	////////////////////////////////////////////////////////////////////////////////
	// WORLD - CAMERA - LIGHTING
	////////////////////////////////////////////////////////////////////////////////

	// create a new world.
	world = new cWorld();

	// set the background color of the environment
	world->m_backgroundColor.setBlack();

	// create a camera and insert it into the virtual world
	camera = new cCamera(world);
	world->addChild(camera);

	// position and orient the camera
	camera->set(cVector3d(0.5, 0.0, 0.0),    // camera position (eye)
		cVector3d(0.0, 0.0, 0.0),    // look at position (target)
		cVector3d(0.0, 0.0, 1.0));   // direction of the (up) vector

// set the near and far clipping planes of the camera
	camera->setClippingPlanes(0.02, 10.0);

	// set stereo mode
	camera->setStereoMode(stereoMode);

	// set stereo eye separation and focal length (applies only if stereo is enabled)
	camera->setStereoEyeSeparation(0.05);
	camera->setStereoFocalLength(0.5);

	// set vertical mirrored display mode
	camera->setMirrorVertical(mirroredDisplay);

	// create a directional light source
	light = new cDirectionalLight(world);

	// insert light source inside world
	world->addChild(light);

	// enable light source
	light->setEnabled(true);

	// define direction of light beam
	light->setDir(-1.0, 0.0, 0.0);

	// create a sphere (cursor) to represent the haptic device
	cursor = new cShapeTorus(0.03, 0.04);

	// insert cursor inside world
	world->addChild(cursor);

	// create small line to illustrate the velocity of the haptic device
	velocity = new cShapeLine(cVector3d(0, 0, 0), cVector3d(0, 0, 0));

	// insert line inside world
	world->addChild(velocity);


	////////////////////////////////////////////////////////////////////////////////
	// HAPTIC DEVICE
	////////////////////////////////////////////////////////////////////////////////

	// create a haptic device handler
	handler = new cHapticDeviceHandler();

	// get a handle to the first haptic device
	handler->getDevice(hapticDevice, 0);
	cHapticDeviceInfo info = hapticDevice->getSpecifications();
	// open a connection with the haptic device
	hapticDevice->open();
	if (info.m_sensedRotation == true)
	{
		// display a reference frame
		cursor->setShowFrame(true);

		// set the size of the reference frame
		cursor->setFrameSize(0.05);
	}

	// retrieve information about the current haptic device
	cHapticDeviceInfo info = hapticDevice->getSpecifications();

	// if the device has a gripper, enable the gripper to behave like a user switch
	hapticDevice->setEnableGripperUserSwitch(true);


	////////////////////////////////////////////////////////////////////////////////
	// WIDGETS
	////////////////////////////////////////////////////////////////////////////////

	// create a font
	font = NEW_CFONTCALIBRI28();

	// create a label to display the haptic device model
	labelHapticDeviceModel = new cLabel(font);
	camera->m_frontLayer->addChild(labelHapticDeviceModel);
	labelHapticDeviceModel->setText(info.m_modelName);
	labelHapticDeviceModel->m_fontColor.setBlueRoyal();

	// create a label to display the position of haptic device
	labelHapticDevicePosition = new cLabel(font);
	camera->m_frontLayer->addChild(labelHapticDevicePosition);

	// create a label to display the haptic and graphic rate of the simulation
	labelRates = new cLabel(font);
	camera->m_frontLayer->addChild(labelRates);

	// create a scope to plot haptic device position data
	scope = new cScope();
	camera->m_frontLayer->addChild(scope);
	scope->setLocalPos(100, 60);
	scope->setRange(-0.1, 0.1);
	scope->createEffectVibration();
	//scope->deleteEffectViscosity();
	scope->setSignalEnabled(true, true, true, true);
	scope->setTransparencyLevel(0.6);


	// 
	labelMax = new cLabel(font);
	camera->m_frontLayer->addChild(labelMax);
	labelMax->setText("-0.1");
	labelMax->setLocalPos(80, 60);


	labelMin = new cLabel(font);
	camera->m_frontLayer->addChild(labelMin);
	labelMin->setText("0.1");

	labelMin->setLocalPos(80, 225);


	labelXd_Prev = new cLabel(font);
	labelXd = new cLabel(font);
	labelX_Recv = new cLabel(font);
	labelFd = new cLabel(font);
	labelIP = new cLabel(font);
	labelDelay = new cLabel(font);

	camera->m_frontLayer->addChild(labelXd_Prev);
	camera->m_frontLayer->addChild(labelXd);
	camera->m_frontLayer->addChild(labelX_Recv);
	camera->m_frontLayer->addChild(labelFd);
	camera->m_frontLayer->addChild(labelDelay);

	camera->m_frontLayer->addChild(labelIP);

	labelIP->setText("Server IP: ");
	labelIP->setLocalPos(20, height - 60);
	labelIP->m_fontColor.setBlueLight();

	labelXd_Prev->setText("Prev Xd: ");
	labelXd_Prev->setLocalPos(20, height - 80);
	labelXd_Prev->m_fontColor.setGreenLight();

	labelXd->setText("Curr Xd: ");

	labelXd->setLocalPos(20, height - 100);
	labelXd->m_fontColor.setOrange();

	labelX_Recv->setText("Recv: ");
	labelX_Recv->setLocalPos(20, height - 120);
	labelX_Recv->m_fontColor.setGreenDark();


	labelFd->setText("Fd: ");
	labelFd->setLocalPos(20, height - 140);
	labelFd->m_fontColor.setRedCrimson();

	labelRates->setText("Frequency: ");
	labelRates->setLocalPos(20, height - 160);
	labelRates->m_fontColor.setPurple();

	labelDelay->setText("Delay: ");
	labelDelay->setLocalPos(20, height - 160);
	labelDelay->m_fontColor.setBlue();
	////////////////////////////////////////////////////////////////////////////////
	// START SIMULATION
	////////////////////////////////////////////////////////////////////////////////

	// create a thread which starts the main haptics rendering loop
	hapticsThread = new cThread();
	hapticsThread->start(updateHaptics, CTHREAD_PRIORITY_HAPTICS);

	// setup callback when application exits
	atexit(close);


	////////////////////////////////////////////////////////////////////////////////
	// MAIN GRAPHIC LOOP
	////////////////////////////////////////////////////////////////////////////////

	// call window size callback at initialization
	windowSizeCallback(window, width, height);
	
	while (!glfwWindowShouldClose(window))
	{
		// get width and height of window
		glfwGetWindowSize(window, &width, &height);

		// render graphics
		updateGraphics();

		// swap buffers
		glfwSwapBuffers(window);

		// process events
		glfwPollEvents();

		// signal frequency counter
		freqCounterGraphics.signal(1);
	}

	// close window
	glfwDestroyWindow(window);

	// terminate GLFW library
	glfwTerminate();

	//Plotdata d(0,100), f = delay;
	//plot(d, f);
	// exit
	/*delay(1000);*/
	return (0);
}
////////mani128////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////





////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void updateHaptics(void)
{
	// simulation in now running
	
	simulationRunning = true;
	simulationFinished = false;
	
	ofstream myFile;
	myFile.open("FalconVALs Updated.csv");
	myFile <<"No."<<","<< "previous position X" << "," << "previous position Y" << "," << "previous position Z" << "," << "current position X" << "," << "current position Y" << "," << "current position Z" << "," << "recv position X" << "," << "recv position Y" << "," << "recv position Z" <<","<< "Delay" << endl;
	//cout << "time" << milli();
	// main haptic simulation loop
	const auto p0 = std::chrono::time_point<std::chrono::system_clock>{};
	
	while (simulationRunning)
	{
		/////////////////////////////////////////////////////////////////////
		// READ HAPTIC DEVICE
		/////////////////////////////////////////////////////////////////////

		// read position 
		cVector3d position;
		hapticDevice->getPosition(position);
		cMatrix3d rotation;

		// read linear velocity 
		cVector3d linearVelocity;
		cVector3d angularVelocity;
		hapticDevice->getLinearVelocity(linearVelocity);
		hapticDevice->getAngularVelocity(angularVelocity);
		cVector3d Force;
		hapticDevice->getForce(Force);
		// read user-switch status (button 0)
		bool button0, button1, button2, button3;

		button0 = false;
		button1 = false;
		button2 = false;
		button3 = false;

		hapticDevice->getUserSwitch(0, button0);
		hapticDevice->getUserSwitch(1, button1);
		hapticDevice->getUserSwitch(2, button2);
		hapticDevice->getUserSwitch(3, button3);

		
		myFile << countd <<","<< pos_prev[0] << "," << pos_prev[1] << "," << pos_prev[2] << "," << pos_curr[0] << "," << pos_curr[1] << "," << pos_curr[2] << "," << pos_recv[0] << "," << pos_recv[1] << "," << pos_recv[2]<< "," << delay << endl;
		/////////////////////////////////////////////////////////////////////
		// UPDATE 3D CURSOR MODEL
		/////////////////////////////////////////////////////////////////////

		// update arrow
		velocity->m_pointA = position;
		velocity->m_pointB = cAdd(position, linearVelocity);

		// update position and orientation of cursor
		cursor->setLocalPos(position);

		// adjust the  color of the cursor according to the status of
		// the user-switch (ON = TRUE / OFF = FALSE)
		if (button0)
		{
			cursor->m_material->setGreenMediumAquamarine();
		}
		else if (button1)
		{
			cursor->m_material->setYellowGold();
		}
		else if (button2)
		{
			cursor->m_material->setOrangeCoral();
		}
		else if (button3)
		{
			cursor->m_material->setPurpleLavender();
		}
		else
		{
			cursor->m_material->setBlueRoyal();
		}

		// update global variable for graphic display update
		hapticDevicePosition = position;
		hapticDeviceVelocity = linearVelocity;


		/////////////////////////////////////////////////////////////////////
		// COMPUTE AND APPLY FORCES
		/////////////////////////////////////////////////////////////////////
		for (int i = 0; i < DOF; i++)
		{
			pos_curr[i] = hapticDevicePosition(i);
		}

		// µ¥ÀÌÅÍ ¹Þ±â
		UDPReadData();

		pos_recv[0] = ReadData[0];
		pos_recv[1] = ReadData[1];
		pos_recv[2] = ReadData[2];

		SendData[0] = pos_curr[0];
		SendData[1] = pos_curr[1];
		SendData[2] = pos_curr[2];

		UDPSendData(SendData);
		
				

		cVector3d force(0, 0, 0);

		double gripperForce = 0.0;
		cVector3d torque(0, 0, 0);

		// apply force field
		if (useForceField)
		{
			// compute linear force
			double Kp = 50; //25; // [N/m]
			cVector3d forceField = -Kp * position;
			force.add(forceField);

			for (int i = 0; i < DOF; i++)
			{
				Fd[i] = Kp * (pos_recv[i] - pos_curr[i]);
				force(i) = Fd[i];

				pos_prev[i] = pos_curr[i];
			}
			// compute angular torque
			double Kr = 0.05; // [N/m.rad]
			cVector3d axis;
			double angle;
			rotation.toAxisAngle(axis, angle);
			torque = (-Kr * angle) * axis;
		}
		if (useDamping)
		{
			cHapticDeviceInfo info = hapticDevice->getSpecifications();

			// compute linear damping force
			double Kv = 0.2 * info.m_maxLinearDamping;
			cVector3d forceDamping = -Kv * linearVelocity;
			force.add(forceDamping);

			// compute angular damping force
			double Kvr = 0.2 * info.m_maxAngularDamping;
			cVector3d torqueDamping = -Kvr * angularVelocity;
			torque.add(torqueDamping);

			//// compute gripper angular damping force
			//double Kvg = 0.2 * info.m_maxGripperAngularDamping;
			//gripperForce = gripperForce - Kvg * gripperAngularVelocity;
		}

		// send computed force
		hapticDevice->setForce(force);

		// update frequency counter
		freqCounterHaptics.signal(1);
	}

	// exit haptics thread
	simulationFinished = true;
	/*const auto p1 = std::chrono::system_clock::now();
	const auto p2 = p1 - std::chrono::hours(24);

	std::time_t epoch_time = std::chrono::system_clock::to_time_t(p0);
	std::cout << "epoch: " << std::ctime(&epoch_time);
	std::time_t today_time = std::chrono::system_clock::to_time_t(p1);
	std::cout << "today: " << std::ctime(&today_time);

	std::cout << "hours since epoch: "
		<< std::chrono::duration_cast<std::chrono::hours>(
			p1.time_since_epoch()).count()
		<< '\n';
	std::cout << "yesterday, hours since epoch: "
		<< std::chrono::duration_cast<std::chrono::hours>(
			p2.time_since_epoch()).count()
		<< '\n';*/
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////





////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void windowSizeCallback(GLFWwindow* a_window, int a_width, int a_height)
{
	// update window size
	width = a_width;
	height = a_height;

	// update position of label
	labelHapticDevicePosition->setLocalPos(20, width - 60, 0);

	// update position of label
	labelHapticDeviceModel->setLocalPos(20, height - 40, 0);

	// update position of scope
	scope->setSize(width - 200, 190);
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void errorCallback(int a_error, const char* a_description)
{
	cout << "Error: " << a_description << endl;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void keyCallback(GLFWwindow* a_window, int a_key, int a_scancode, int a_action, int a_mods)
{

	/*while (!simulationFinished) {


		if (a_key == GLFW_KEY_I)
		{
			swapInterval++;
			cout << endl << "SwapInterval + 1 =" << swapInterval<<endl;
			break;
		}
		else if (a_key == GLFW_KEY_D)
		{
			swapInterval--;
			cout << endl << "SwapInterval - 1 =" << swapInterval << endl;
			break;
		}*/


		// option - toggle fullscreen
	if (a_key == GLFW_KEY_F)
	{
		// toggle state variable
		fullscreen = !fullscreen;

		// get handle to monitor
		GLFWmonitor* monitor = glfwGetPrimaryMonitor();

		// get information about monitor
		const GLFWvidmode* mode = glfwGetVideoMode(monitor);

		// set fullscreen or window mode
		if (fullscreen)
		{
			glfwSetWindowMonitor(window, monitor, 0, 0, mode->width, mode->height, mode->refreshRate);
			glfwSwapInterval(swapInterval);
		}
		else
		{
			int w = 0.8 * mode->height;
			int h = 0.5 * mode->height;
			int x = 0.5 * (mode->width - w);
			int y = 0.5 * (mode->height - h);
			glfwSetWindowMonitor(window, NULL, x, y, w, h, mode->refreshRate);
			glfwSwapInterval(swapInterval);
		}
	}
	// filter calls that only include a key press
	if ((a_action != GLFW_PRESS) && (a_action != GLFW_REPEAT))
	{

		return;
	}

	// option - exit
	if ((a_key == GLFW_KEY_ESCAPE) || (a_key == GLFW_KEY_Q))
	{
		glfwSetWindowShouldClose(a_window, GLFW_TRUE);
	}
	// option - toggle vertical mirroring
	if (a_key == GLFW_KEY_M)
	{
		mirroredDisplay = !mirroredDisplay;
		camera->setMirrorHorizontal(mirroredDisplay);

	}
	// option - enable/disable damping
	if (a_key == GLFW_KEY_2)
	{
		useDamping = !useDamping;
		if (useDamping)
			cout << "> Enable damping         \r";
		else
			cout << "> Disable damping        \r";
	}
	// option - enable/disable force field
	if (a_key == GLFW_KEY_1)
	{
		useForceField = !useForceField;
		if (useForceField)
			cout << "> Enable force field     \r";
		else
			cout << "> Disable force field    \r";

	}
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void close(void)
{
	CloseUDP();
	// stop the simulation
	simulationRunning = false;

	// wait for graphics and haptics loops to terminate
	while (!simulationFinished)
	{
		cSleepMs(100);
	}

	// close haptic device
	hapticDevice->close();

	// delete resources
	delete hapticsThread;
	delete world;
	delete handler;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void InitUDP()
{
	// À©¼Ó ÃÊ±âÈ
	if (WSAStartup(MAKEWORD(2, 2), &wsa) != 0)
	{
		MessageBox(NULL, "Socket Open Error!!", "UDP", MB_OK);
	}


	// socket()
	sock = socket(AF_INET, SOCK_DGRAM, 0);
	if (sock == INVALID_SOCKET)
	{
		err_quit("socket()");
	}

	// bind()
	ZeroMemory(&serveraddr, sizeof(serveraddr));
	serveraddr.sin_family = AF_INET;
	serveraddr.sin_port = htons(UDP_PORT);
	serveraddr.sin_addr.s_addr = inet_addr(SERVER_IP);
	retval = ::bind(sock, (SOCKADDR*)&serveraddr, sizeof(serveraddr));

}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CloseUDP()
{
	// closesocket()
	closesocket(sock);

	// À©¼Ó Á¾·á
	WSACleanup();
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


void UDPSendData(float sData[SENDDATA_NUM])

{
		//sprintf(sbuf, "%f %f %f %f %f %f %f %f %f %f %f %f %f %f %f %f %f %f %f %f", sData[0], sData[1], sData[2], sData[3], sData[4], sData[5], sData[6], sData[7], sData[8], sData[9], sData[10], sData[11], sData[12], sData[13], sData[14], sData[15], sData[16], sData[17], sData[18], sData[19]);
	Timer time;
	sprintf(sbuf, "%f %f %f %f", sData[0], sData[1], sData[2], sData[3]);
	retval = sendto(sock, sbuf, strlen(sbuf), 0, (SOCKADDR*)&clientaddr, sizeof(clientaddr));
	if (retval == SOCKET_ERROR)
	{
		err_display("sendto()");
		exit(-1);
	}
		
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void UDPReadData()
{
	Timer2 time;
	addrlen = sizeof(clientaddr);
	retval = recvfrom(sock, rbuf, BUFSIZE, 0, (SOCKADDR*)&clientaddr, &addrlen);
	if (retval == SOCKET_ERROR)
	{
		err_display("recvfrom()");
		exit(-1);
		//cout << "time_elapsed" << milli();
	}
	//sscanf(rbuf, "%f %f %f %f %f %f %f %f %f %f %f %f %f %f %f %f %f %f %f %f", &ReadData[0], &ReadData[1], &ReadData[2], &ReadData[3], &ReadData[4], &ReadData[5], &ReadData[6], &ReadData[7], &ReadData[8], &ReadData[9], &ReadData[10], &ReadData[11], &ReadData[12], &ReadData[13], &ReadData[14], &ReadData[15], &ReadData[16], &ReadData[17], &ReadData[18], &ReadData[19]);
	(sscanf(rbuf,"%f %f %f %f", &ReadData[0], &ReadData[1], &ReadData[2]) ,& ReadData[3]);
	delay = timeUDPS - timeUDPR;
	countd = countd++;
	cout <<countd<< " Delay calculated " << " " << delay << " " << " milliseconds" << endl;
}
void updateGraphics(void)
{

	/////////////////////////////////////////////////////////////////////
	// UPDATE WIDGETS
	/////////////////////////////////////////////////////////////////////

	// update position data
	labelHapticDevicePosition->setText(hapticDevicePosition.str(3));

	// update haptic and graphic rate data
	labelRates->setText(cStr(freqCounterGraphics.getFrequency(), 0) + " Hz / " +
		cStr(freqCounterHaptics.getFrequency(), 0) + " Hz");

	// update position of label
	labelRates->setLocalPos((int)(0.5 * (width - labelRates->getWidth())), 15);


	// update information to scope
	scope->setSignalValues(hapticDevicePosition.x(), hapticDevicePosition.y(), hapticDevicePosition.z());
	//scope->setSignalValues(hapticDeviceVelocity.x(), hapticDeviceVelocity.y(), hapticDeviceVelocity.z());


	labelIP->setText("Client IP: " + string(inet_ntoa(clientaddr.sin_addr)) + ":" + cStr(ntohs(clientaddr.sin_port)));
	labelXd_Prev->setText("Prev Xd: " + cStr(pos_prev[0], 3U) + "  " + cStr(pos_prev[1], 3U) + "  " + cStr(pos_prev[2], 3U));
	labelXd->setText("Curr Xd: " + cStr(pos_curr[0], 3U) + "  " + cStr(pos_curr[1], 3U) + "  " + cStr(pos_curr[2], 3U));
	labelX_Recv->setText("Recv X: " + cStr(pos_recv[0], 3U) + "  " + cStr(pos_recv[1], 3U) + "  " + cStr(pos_recv[2], 3U));
	labelFd->setText("Fd: " + cStr(Fd[0], 3U) + "  " + cStr(Fd[1], 3U) + "  " + cStr(Fd[2], 3U));
	labelDelay->setText("Delay: " + cStr(delay, 3U) + "ms");

	//cVector3d linearVelocity;
	//hapticDevice->getLinearVelocity(linearVelocity);

	//cout << "Linear Velocity" << "(" << linearVelocity << ")" << endl;
	/*cout << endl;
	cout << "Prev position:" << "(" << pos_prev[0] << "," << pos_prev[1] << "," << pos_prev[2] << ")" << endl;
	cout << "Curr position:" << "(" << pos_curr[0] << "," << pos_curr[1] << "," << pos_curr[2] << ")" << endl;
	cout << "Recv position:" << "(" << pos_recv[0] << "," << pos_recv[1] << "," << pos_recv[2] << ")" << endl;
*/
	
	/////////////////////////////////////////////////////////////////////
	// RENDER SCENE
	/////////////////////////////////////////////////////////////////////

	// update shadow maps (if any)
	world->updateShadowMaps(false, mirroredDisplay);

	// render world
	camera->renderView(width, height);

	// wait until all OpenGL commands are completed
	glFinish();

	// check for any OpenGL errors
	GLenum err;
	err = glGetError();
	if (err != GL_NO_ERROR) cout << "Error:  %s\n" << gluErrorString(err);
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// ¼ÒÄÏ ÇÔ¼ö ¿À·ù Ãâ·Â ÈÄ Á¾·á
void err_quit(const char* msg)
{
	LPVOID lpMsgBuf;

	FormatMessage(
		FORMAT_MESSAGE_ALLOCATE_BUFFER |
		FORMAT_MESSAGE_FROM_SYSTEM,
		NULL, WSAGetLastError(),
		MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),

		(LPTSTR)&lpMsgBuf, 0, NULL);
	MessageBox(NULL, (LPCTSTR)lpMsgBuf, msg, MB_ICONERROR);
	LocalFree(lpMsgBuf);
	exit(-1);
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// ¼ÒÄÏ ÇÔ¼ö ¿À·ù Ãâ·Â
void err_display(const char* msg)
{
	LPVOID lpMsgBuf;
	FormatMessage(
		FORMAT_MESSAGE_ALLOCATE_BUFFER |
		FORMAT_MESSAGE_FROM_SYSTEM,
		NULL, WSAGetLastError(),
		MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
		(LPTSTR)&lpMsgBuf, 0, NULL);

	printf("[%s] %s", msg, (LPCTSTR)lpMsgBuf);
	LocalFree(lpMsgBuf);
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
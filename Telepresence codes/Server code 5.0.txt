#include <stdlib.h>
#include <stdio.h>
#include <fstream>
//#include <time.h>
#include <chrono>
#include <string.h>
#include <winsock2.h>
#include "chai3d.h"
#include <GLFW/glfw3.h>
#include <E:\NCRA Lab Dr Riazuddin\Falcon_Vwall_Test\[lwtFiles]\lwtMenuGL.h>
#include <E:\NCRA Lab Dr Riazuddin\Falcon_Vwall_Test\Source\Haptics.h>
#include <E:\NCRA Lab Dr Riazuddin\Falcon_Vwall_Test\Source\NIDAQmx.h>

#pragma comment(lib, "ws2_32.lib")

////////////////////////////////////////////////////////////////////////////////
using namespace chai3d;
using namespace std;


////////////////////////////////////////////////////////////////////////////////
// Device Param.
////////////////////////////////////////////////////////////////////////////////
#define DOF 3

double pos_curr[DOF] = { 0, 0, 0 };
double pos_prev[DOF] = { 0, 0, 0 };
double pos_recv[DOF] = { 0, 0, 0 };
double Fd[DOF];
double delay = 0;
double delaym = 0;
int countd = 0;
////////////////////////////////////////////////////////////////////////////////
// UDP Param.
////////////////////////////////////////////////////////////////////////////////
#define BUFSIZE 4096
#define SERVER_IP "192.168.0.100" // "127.0.0.1" // "111.68.110.189"  "203.237.55.14"\\lithuania
#define UDP_PORT 4000
#define SENDDATA_NUM 3
#define READDATA_NUM 3
string Server= SERVER_IP;
string Server2;
//int Range;
int retval;
WSADATA wsa;
int TAP;
double avg_delay;
SOCKET sock;

// µ¥ÀÌÅÍ Åë½Å¿¡ »ç¿ëÇÒ º¯¼ö
SOCKADDR_IN serveraddr;
SOCKADDR_IN clientaddr;

int addrlen;
char sbuf[BUFSIZE + 1], rbuf[BUFSIZE + 1];
int timeUDPR;
int timeUDPS;
//int v=2;
//int i;
//int sum;
//int arrd[1000] = {};
//int average_d;
//
//int arr_delay[500];

float SendData[SENDDATA_NUM], ReadData[READDATA_NUM];

bool isFirstRecv = false;
struct Timer
{
	chrono::time_point<std::chrono::steady_clock>start, end;
	chrono::duration<float>duration;
	Timer()
	{
		start = std::chrono::high_resolution_clock::now();

	}
	~Timer()
	{
		end = std::chrono::high_resolution_clock::now();
		duration = end - start;
		float ms = duration.count() * 1000.0f;
		timeUDPR = ms;
		//cout << "Timer took" << ms << "ms" << endl;

	}
};
struct Timer2
{
	chrono::time_point<std::chrono::steady_clock>start, end;
	chrono::duration<float>duration;
	Timer2()
	{
		start = std::chrono::high_resolution_clock::now();

	}
	~Timer2()
	{
		end = std::chrono::high_resolution_clock::now();
		duration = end - start;
		float ms = duration.count() * 1000.0f;
		timeUDPS = ms;
		//cout << "Timer took" << ms << "ms" << endl;

	}
};
////////////////////////////////////////////////////////////////////////////////
// Delay Param.
////////////////////////////////////////////////////////////////////////////////
#define DELAY 1
#define DELAYDATA_NUM 4

double ClientData[DELAYDATA_NUM];
double DelayDataBuf[DELAYDATA_NUM][DELAY];
double DelayData[DELAYDATA_NUM];
//double delay[DELAY] = { 0 };

////////////////////////////////////////////////////////////////////////////////
// GUI - GENERAL SETTINGS
////////////////////////////////////////////////////////////////////////////////

// stereo Mode
/*
	C_STEREO_DISABLED:            Stereo is disabled
	C_STEREO_ACTIVE:              Active stereo for OpenGL NVDIA QUADRO cards
	C_STEREO_PASSIVE_LEFT_RIGHT:  Passive stereo where L/R images are rendered next to each other
	C_STEREO_PASSIVE_TOP_BOTTOM:  Passive stereo where L/R images are rendered above each other
*/
cStereoMode stereoMode = C_STEREO_DISABLED;

// fullscreen mode
bool fullscreen = false;

// mirrored display
bool mirroredDisplay = false;


//// a flag for using damping (ON/OFF)
bool useDamping = false;
//
//// a flag for using force field (ON/OFF)
//bool useForceField = true;

////////////////////////////////////////////////////////////////////////////////
// GUI - DECLARED VARIABLES
////////////////////////////////////////////////////////////////////////////////

// a world that contains all objects of the virtual environment
cWorld* world;

// a camera to render the world in the window display
cCamera* camera;

// a light source to illuminate the objects in the world
cDirectionalLight* light;

// a haptic device handler
cHapticDeviceHandler* handler;

// a pointer to the current haptic device
cGenericHapticDevicePtr hapticDevice;

// a label to display the haptic device model
cLabel* labelHapticDeviceModel;

// a label to display the position [m] of the haptic device
cLabel* labelHapticDevicePosition;

// a global variable to store the position [m] of the haptic device
cVector3d hapticDevicePosition;

// a global variable to store the velocity [m/s] of the haptic device
cVector3d hapticDeviceVelocity;

// a font for rendering text
cFontPtr font;

// a label to display the rate [Hz] at which the simulation is running
cLabel* labelRates;

cLabel* labelMax;
cLabel* labelMin;

cLabel* labelXd;
cLabel* labelXd_Prev;

cLabel* labelX_Recv;
cLabel* labelFd;

cLabel* labelIP;
cLabel* labelDelay;
cLabel* labeldelay2;
cLabel* labeldelay3;


// a small sphere (cursor) representing the haptic device 
cShapeTorus* cursor;

// a line representing the velocity of the haptic device
cShapeLine* velocity;

// a scope to monitor position values of haptic device
cScope* scope;
cScope* scope2;
cScope* scope1;
cLevel* levelVelocity;
// a flag for using force field (ON/OFF)
bool useForceField = true;

// a flag to indicate if the haptic simulation currently running
bool simulationRunning = false;

// a flag to indicate if the haptic simulation has terminated
bool simulationFinished = true;

// a frequency counter to measure the simulation graphic rate
cFrequencyCounter freqCounterGraphics;

// a frequency counter to measure the simulation haptic rate
cFrequencyCounter freqCounterHaptics;

// haptic thread
cThread* hapticsThread;

// a handle to window display context
GLFWwindow* window = NULL;

// current width of window
int width = 0;

// current height of window
int height = 0;

// swap interval for the display context (vertical synchronization)
int swapInterval = 1;


////////////////////////////////////////////////////////////////////////////////
// GUI - DECLARED FUNCTIONS
////////////////////////////////////////////////////////////////////////////////

// callback when the window display is resized
void windowSizeCallback(GLFWwindow* a_window, int a_width, int a_height);

// callback when an error GLFW occurs
void errorCallback(int error, const char* a_description);

// callback when a key is pressed
void keyCallback(GLFWwindow* a_window, int a_key, int a_scancode, int a_action, int a_mods);

// this function renders the scene
void updateGraphics(void);

// this function contains the main haptics simulation loop
void updateHaptics(void);

// this function closes the application
void close(void);

void InitUDP(void);
void modifiedEBA(void);
void UDPSendData(float sData[SENDDATA_NUM]);
void UDPReadData();
void err_quit(const char* msg);
void err_display(const char* msg);
void CloseUDP();
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////
//								EBA Parameters							//
//////////////////////////////////////////////////////////////////////////
//double	c1, c2;	// N/m
//VECTOR	uBETA, BETA, Bmax, Bmin;
double uBETA[3], BETA[3], Bmax[3], Bmin[3];
//c1=b/T
//b=KT/2
//high force K = 20kN/m
//b=10
//c1=0.01
double c1 = 5.0;
double c2;
double Ke = 1.0;
//extern lwtButton bEBA;
//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////
//							Device Parameters							//
//////////////////////////////////////////////////////////////////////////
VECTOR POS, HIP, pHIP, IHIP, DHIP, vHIP;
VECTOR FOR, pFOR, FORCE, F_sensing, T_sensing;
VECTOR Xd, Vd, XdP, Xe, XeP, Ve, Fe, dFe, FdP, DXd, rDXd;
double MaxForce = 8.5;
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//							Flag Parameters								//
//////////////////////////////////////////////////////////////////////////
bool EnableMultiRate = false;
bool EnableEBA = true;
bool EnableImpulse = false;
bool EnableMoving = false;
//////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int main(int argc, char* argv[])
{
	InitUDP();

	////////////////////////////////////////////////////////////////////////////////
	// INITIALIZATION
	////////////////////////////////////////////////////////////////////////////////

	cout << endl;
	cout << "-----------------------------------" << endl;
	cout << "Dr. Riazuddin Teleoperation (SERVER)" << endl;
	cout << "-----------------------------------" << endl << endl << endl;
	cout << "Keyboard Options:" << endl << endl;
	cout << "[1] - Enable/Disable potential field" << endl;
	cout << "[f] - toggle fullscreen" << endl;
	cout << "[M] - Mirrored Display" << endl;
	cout << "[q] - Exit application" << endl;
	cout << " " << endl;
	cout << "********************" << endl;

	////////////////////////////////////////////////////////////////////////////////
	// OPEN GL - WINDOW DISPLAY
	////////////////////////////////////////////////////////////////////////////////

	if (!glfwInit())
	{
		cout << "failed initialization" << endl;
		cSleepMs(1000);
		return 1;
	}

	// set error callback
	glfwSetErrorCallback(errorCallback);

	// compute desired size of window
	const GLFWvidmode* mode = glfwGetVideoMode(glfwGetPrimaryMonitor());
	int w = 1.1 * mode->height;
	int h = 0.85 * mode->height;
	int x = 0.7 * (mode->width - w);
	int y = 0.7 * (mode->height - h);


	// set OpenGL version
	glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 2);
	glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 1);

	// set active stereo mode
	if (stereoMode == C_STEREO_ACTIVE)
	{
		glfwWindowHint(GLFW_STEREO, GL_TRUE);
	}
	else
	{
		glfwWindowHint(GLFW_STEREO, GL_FALSE);
	}

	// create display context
	window = glfwCreateWindow(w, h, "Dr. Riazuddin Teleoperation (SERVER)", NULL, NULL);
	if (!window)
	{
		cout << "failed to create window" << endl;
		cSleepMs(10);
		glfwTerminate();
		return 1;
	}

	// get width and height of window
	glfwGetWindowSize(window, &width, &height);

	// set position of window
	glfwSetWindowPos(window, x, y);

	// set key callback
	glfwSetKeyCallback(window, keyCallback);

	// set resize callback
	glfwSetWindowSizeCallback(window, windowSizeCallback);

	// set current display context
	glfwMakeContextCurrent(window);

	// sets the swap interval for the current display context
	glfwSwapInterval(swapInterval);

#ifdef GLEW_VERSION
	// initialize GLEW library
	if (glewInit() != GLEW_OK)
	{
		cout << "failed to initialize GLEW library" << endl;
		glfwTerminate();
		return 1;
	}
#endif


	////////////////////////////////////////////////////////////////////////////////
	// WORLD - CAMERA - LIGHTING
	////////////////////////////////////////////////////////////////////////////////

	// create a new world.
	world = new cWorld();

	// set the background color of the environment
	world->m_backgroundColor.setBlack();

	// create a camera and insert it into the virtual world
	camera = new cCamera(world);
	world->addChild(camera);

	// position and orient the camera
	camera->set(cVector3d(0.5, 0.0, 0.0),    // camera position (eye)
		cVector3d(0.0, 0.0, 0.0),    // look at position (target)
		cVector3d(0.0, 0.0, 1.0));   // direction of the (up) vector

// set the near and far clipping planes of the camera
	camera->setClippingPlanes(0.02, 10.0);

	// set stereo mode
	camera->setStereoMode(stereoMode);

	// set stereo eye separation and focal length (applies only if stereo is enabled)
	camera->setStereoEyeSeparation(0.05);
	camera->setStereoFocalLength(0.5);

	// set vertical mirrored display mode
	camera->setMirrorVertical(mirroredDisplay);

	// create a directional light source
	light = new cDirectionalLight(world);

	// insert light source inside world
	world->addChild(light);

	// enable light source
	light->setEnabled(true);

	// define direction of light beam
	light->setDir(-1.0, 1.0, 0.0);

	// create a sphere (cursor) to represent the haptic device
	cursor = new cShapeTorus(0.03, 0.04);

	// insert cursor inside world
	world->addChild(cursor);

	// create small line to illustrate the velocity of the haptic device
	velocity = new cShapeLine(cVector3d(0, 0, 0), cVector3d(0, 0, 0));

	// insert line inside world
	world->addChild(velocity);


	////////////////////////////////////////////////////////////////////////////////
	// HAPTIC DEVICE
	////////////////////////////////////////////////////////////////////////////////

	// create a haptic device handler
	handler = new cHapticDeviceHandler();

	// get a handle to the first haptic device
	handler->getDevice(hapticDevice, 0);

	// open a connection with the haptic device
	hapticDevice->open();

	// retrieve information about the current haptic device
	cHapticDeviceInfo info = hapticDevice->getSpecifications();

	// if the device has a gripper, enable the gripper to behave like a user switch
	hapticDevice->setEnableGripperUserSwitch(true);


	////////////////////////////////////////////////////////////////////////////////
	// WIDGETS
	////////////////////////////////////////////////////////////////////////////////

	// create a font
	font = NEW_CFONTCALIBRI28();

	// create a label to display the haptic device model
	labelHapticDeviceModel = new cLabel(font);
	camera->m_frontLayer->addChild(labelHapticDeviceModel);
	labelHapticDeviceModel->setText(info.m_modelName);
	labelHapticDeviceModel->m_fontColor.setBlueRoyal();

	// create a label to display the position of haptic device
	labelHapticDevicePosition = new cLabel(font);
	camera->m_frontLayer->addChild(labelHapticDevicePosition);

	// create a label to display the haptic and graphic rate of the simulation
	labelRates = new cLabel(font);
	camera->m_frontLayer->addChild(labelRates);

	// create a scope to plot haptic device position data
	scope = new cScope();
	camera->m_frontLayer->addChild(scope);
	scope->setLocalPos(100, 60);
	scope->setRange(-0.1, 0.1);
	//scope->createEffectVibration();
	//scope->createEffectViscosity();
	scope->setSignalEnabled(true, true, true, true);
	scope->setTransparencyLevel(0.6);
	

	//double getRangeMax(delay);
	Server2 = Server.substr(0, 3);
	//cout << Server2;
	if (Server2 == "192") {
		//Range = 15;
		labelMax = new cLabel(font);
		camera->m_frontLayer->addChild(labelMax);
		labelMax->setText("Teleoperation running over WAN");
		labelMax->setLocalPos(20, height-160);
		labelMax->m_fontColor.setWhite();
	}
	else if (Server2 == "172") {
		//Range = 20;
		labelMax = new cLabel(font);
		camera->m_frontLayer->addChild(labelMax);
		labelMax->setText("Teleoperation running over LAN");
		labelMax->setLocalPos(20, height - 160);
		labelMax->m_fontColor.setWhite();
	}
	
	else if (Server2 == "127") {
		//Range = 20;
		labelMax = new cLabel(font);
		camera->m_frontLayer->addChild(labelMax);
		labelMax->setText("Teleoperation running over LAN");
		labelMax->setLocalPos(20, height - 160);
		labelMax->m_fontColor.setWhite();
	}
	else {
		//Range = 700;
		labelMax = new cLabel(font);
		camera->m_frontLayer->addChild(labelMax);
		labelMax->setText("Teleoperation running over WAN");
		labelMax->setLocalPos(20, height-160);
	}

	
	scope1 = new cScope();
	camera->m_frontLayer->addChild(scope1);
	scope1->setLocalPos(width-290, 680);
	scope1->setRange(0,25);
	//scope1->createEffectVibration();
	//scope->createEffectViscosity();
	scope1->setSignalEnabled(true, true, false, false);
	scope1->setTransparencyLevel(0.6);


	scope2 = new cScope();
	camera->m_frontLayer->addChild(scope2);
	scope2->setLocalPos(width - 290, 480);
	scope2->setRange(0, 200);
	scope2->setSignalEnabled(true, true, false, false);
	scope2->setTransparencyLevel(0.5);


	// create a level to display velocity data
	levelVelocity = new cLevel();
	camera->m_frontLayer->addChild(levelVelocity);
	levelVelocity->setLocalPos(60,60);
	levelVelocity->setRange(0.0, 200);
	levelVelocity->setWidth(40);
	levelVelocity->setNumIncrements(100);
	levelVelocity->setSingleIncrementDisplay(false);
	levelVelocity->setTransparencyLevel(0.7);

	//position scope ranges
	labelMax = new cLabel(font);
	camera->m_frontLayer->addChild(labelMax);
	labelMax->setText("-0.1");
	labelMax->setLocalPos(110, 60);


	labelMin = new cLabel(font);
	camera->m_frontLayer->addChild(labelMin);
	labelMin->setText("0.1");
	labelMin->setLocalPos(110, 430);
	////////////////////////////////////

	//Delay limits
	labelMax = new cLabel(font);
	camera->m_frontLayer->addChild(labelMax);
	labelMax->setText("0");
	labelMax->setLocalPos(40,50);


	labelMin = new cLabel(font);
	camera->m_frontLayer->addChild(labelMin);
	labelMin->setText("200");
	labelMin->setLocalPos(20, 450);
	//////////////////////////////////////
	//position scope name
	labelMin = new cLabel(font);
	camera->m_frontLayer->addChild(labelMin);
	labelMin->setText("Position Scope");
	labelMin->m_fontColor.setGreen();
	labelMin->setLocalPos((int)(0.85 * (width - labelMin->getWidth())), 470);
	//////////////////////////////////
	//delay scope range
	labelMax = new cLabel(font);
	camera->m_frontLayer->addChild(labelMax);
	labelMax->setText("0");
	labelMax->setLocalPos(width-350, 690);

	labelMax = new cLabel(font);
	camera->m_frontLayer->addChild(labelMax);
	labelMax->setText("Time");
	labelMax->setLocalPos(width-80, 680);

	
	////////////////////////


	labelMax = new cLabel(font);
	camera->m_frontLayer->addChild(labelMax);
	labelMax->setText("Delay");
	labelMax->setLocalPos(0, 240);

	labelMax = new cLabel(font);
	camera->m_frontLayer->addChild(labelMax);
	labelMax->setText("level");
	labelMax->setLocalPos(0, 220);
	//labelMin = new cLabel(font);
	//camera->m_frontLayer->addChild(labelMin);
	//labelMin->setText("15");
	//labelMin->setLocalPos(width-350, 950);

	labelMin = new cLabel(font);
	camera->m_frontLayer->addChild(labelMin);
	labelMin->setText("RTT (Delay)");
	labelMin->setLocalPos(width-390, 820);

	labelMin = new cLabel(font);
	camera->m_frontLayer->addChild(labelMin);
	labelMin->setText("Delay Scope");
	labelMin->m_fontColor.setOrange();
	labelMin->setLocalPos((int)(0.5 * (width - labelMin->getWidth())),740 );

	labelXd_Prev = new cLabel(font);
	labelXd = new cLabel(font);
	labelX_Recv = new cLabel(font);
	labelFd = new cLabel(font);
	labelIP = new cLabel(font);
	labeldelay2 = new cLabel(font);
	labelDelay = new cLabel(font);
	labeldelay3 = new cLabel(font);

	camera->m_frontLayer->addChild(labelXd_Prev);
	camera->m_frontLayer->addChild(labelXd);
	camera->m_frontLayer->addChild(labelX_Recv);
	camera->m_frontLayer->addChild(labelFd);
	camera->m_frontLayer->addChild(labelDelay);

	camera->m_frontLayer->addChild(labelIP);
	camera->m_frontLayer->addChild(labeldelay2);
	camera->m_frontLayer->addChild(labeldelay3);
	

	labelIP->setText("Server IP: ");
	labelIP->setLocalPos(20, height - 60);
	labelIP->m_fontColor.setBlueLight();

	labeldelay2->setText("Max: ");
	labeldelay2->setLocalPos(width- 400, 940);
	labeldelay2->m_fontColor.setWhite();

	labeldelay3->setText("Avg_delay: ");
	labeldelay3->setLocalPos(width - 200, 940);
	labeldelay3->m_fontColor.setWhite();

	labelXd_Prev->setText("Prev Xd: ");
	labelXd_Prev->setLocalPos(20, height - 80);
	labelXd_Prev->m_fontColor.setGreenLight();

	labelXd->setText("Curr Xd: ");

	labelXd->setLocalPos(20, height - 100);
	labelXd->m_fontColor.setOrange();

	labelX_Recv->setText("Recv: ");
	labelX_Recv->setLocalPos(20, height - 120);
	labelX_Recv->m_fontColor.setGreenDark();


	labelFd->setText("Fd: ");
	labelFd->setLocalPos(20, height - 140);
	labelFd->m_fontColor.setRedCrimson();

	labelRates->setText("Frequency: ");
	labelRates->setLocalPos(100, height - 160);
	labelRates->m_fontColor.setWhite();
	
	labelDelay->setText("Delay: ");
	labelDelay->setLocalPos(1000, 650);
	labelDelay->m_fontColor.setWhite();
	////////////////////////////////////////////////////////////////////////////////
	// START SIMULATION
	////////////////////////////////////////////////////////////////////////////////

	// create a thread which starts the main haptics rendering loop
	hapticsThread = new cThread();
	hapticsThread->start(updateHaptics, CTHREAD_PRIORITY_HAPTICS);

	// setup callback when application exits
	atexit(close);


	////////////////////////////////////////////////////////////////////////////////
	// MAIN GRAPHIC LOOP
	////////////////////////////////////////////////////////////////////////////////

	// call window size callback at initialization
	windowSizeCallback(window, width, height);

	while (!glfwWindowShouldClose(window))
	{
		// get width and height of window
		glfwGetWindowSize(window, &width, &height);

		// render graphics
		updateGraphics();

		// swap buffers
		glfwSwapBuffers(window);

		// process events
		glfwPollEvents();

		// signal frequency counter
		freqCounterGraphics.signal(1);
	}

	// close window
	glfwDestroyWindow(window);

	// terminate GLFW library
	glfwTerminate();

	// exit
	return (0);
}
/////******************************************************************************************************************////////

void updateHaptics(void)
{
	// simulation in now running
	simulationRunning = true;
	simulationFinished = false;

	ofstream myFile;
	myFile.open("FalconVALs Updated.csv");
	myFile << "No." << "," << "previous position X" << "," << "previous position Y" << "," << "previous position Z" << "," << "current position X" << "," << "current position Y" << "," << "current position Z" << "," << "recv position X" << "," << "recv position Y" << "," << "recv position Z" << "," << "Delay" << endl;


	// main haptic simulation loop
	while (simulationRunning)
	{
		/////////////////////////////////////////////////////////////////////
		// READ HAPTIC DEVICE
		/////////////////////////////////////////////////////////////////////

		// read position 
		cVector3d position;
		hapticDevice->getPosition(position);

		// read linear velocity 
		cVector3d linearVelocity;
		hapticDevice->getLinearVelocity(linearVelocity);
		cVector3d Force;
		hapticDevice->getForce(Force);
		// read user-switch status (button 0)
		bool button0, button1, button2, button3;

		button0 = false;
		button1 = false;
		button2 = false;
		button3 = false;

		hapticDevice->getUserSwitch(0, button0);
		hapticDevice->getUserSwitch(1, button1);
		hapticDevice->getUserSwitch(2, button2);
		hapticDevice->getUserSwitch(3, button3);

		/////////////////////////////////////////////////////

		
		
		myFile << countd << "," << pos_prev[0] << "," << pos_prev[1] << "," << pos_prev[2] << "," << pos_curr[0] << "," << pos_curr[1] << "," << pos_curr[2] << "," << pos_recv[0] << "," << pos_recv[1] << "," << pos_recv[2] << "," << delay << endl;/////////////////////////////////////////////////////////////////////
		// UPDATE 3D CURSOR MODEL
		/////////////////////////////////////////////////////////////////////
		
		// update arrow
		velocity->m_pointA = position;
		velocity->m_pointB = cAdd(position, linearVelocity);

		// update position and orientation of cursor
		cursor->setLocalPos(position);

		// adjust the  color of the cursor according to the status of
		// the user-switch (ON = TRUE / OFF = FALSE)
		if (button0)
		{
			cursor->m_material->setGreenMediumAquamarine();
			for (int G = 0; G >= 0; G++)
			{
				TAP = 0;

				break;
			}
		}
		else if (button1)
		{
			cursor->m_material->setYellowGold();
			for (int G = 0; G >= 0; G++)
			{
				TAP = TAP- 1;
				//cout << TAP;
				if (TAP == -1 && -2 && -3 && -4 && -5 && -6 && -7 && -8 && -9)
				{
					TAP = 0;
				}

				break;
			}
		}
		else if (button2)
		{
			cursor->m_material->setOrangeCoral();
			
		}
		else if (button3)
		{
			cursor->m_material->setPurpleLavender();
			for (int C = 0; C >= 0; C++)
			{
				TAP = TAP + 1;
				//cout << TAP;
				break;
			}
		}
		else
		{
			cursor->m_material->setBlueRoyal();
		}

		// update global variable for graphic display update
		hapticDevicePosition = position;
		//hapticDeviceVelocity = linearVelocity;

		/////////////////////////////////////////////////////////////////////
		// COMPUTE AND APPLY FORCES
		/////////////////////////////////////////////////////////////////////
		for (int i = 0; i < DOF; i++)
		{
			pos_curr[i] = hapticDevicePosition(i);
		}

		// µ¥ÀÌÅÍ ¹Þ±â
		UDPReadData();

		pos_recv[0] = ReadData[0];
		pos_recv[1] = ReadData[1];
		pos_recv[2] = ReadData[2];

		SendData[0] = pos_curr[0];
		SendData[1] = pos_curr[1];
		SendData[2] = pos_curr[2];

		UDPSendData(SendData);


		cVector3d force(0, 0, 0);

		double gripperForce = 0.0;

		// apply force field
		if (useForceField)
		{
			// compute linear force
			double Kp = 50; //25; // [N/m]
			cVector3d forceField = -Kp * position;
			force.add(forceField);

			for (int i = 0; i < DOF; i++)
			{
				Fd[i] = Kp * (pos_recv[i] - pos_curr[i]);
				force(i) = Fd[i];

				pos_prev[i] = pos_curr[i];
			}
		}
		
		// send computed force
		hapticDevice->setForce(force);

		// update frequency counter
		freqCounterHaptics.signal(1);
	}
	
	// exit haptics thread
	simulationFinished = true;



}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	
void windowSizeCallback(GLFWwindow* a_window, int a_width, int a_height)
{
	// update window size
	width = a_width;
	height = a_height;

	// update position of label
	labelHapticDevicePosition->setLocalPos(20, width - 60, 0);

	// update position of label
	labelHapticDeviceModel->setLocalPos(20, height - 40, 0);

	// update position of scope
	scope->setSize(width-200, 400);
	scope1->setSize(width-1000, 300);
	scope2->setSize(width - 1000,  150);

	//cout << TAP;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void errorCallback(int a_error, const char* a_description)
{
	cout << "Error: " << a_description << endl;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void keyCallback(GLFWwindow* a_window, int a_key, int a_scancode, int a_action, int a_mods)
{

	/*while (!simulationFinished) {


		if (a_key == GLFW_KEY_I)
		{
			swapInterval++;
			cout << endl << "SwapInterval + 1 =" << swapInterval<<endl;
			break;
		}
		else if (a_key == GLFW_KEY_D)
		{
			swapInterval--;
			cout << endl << "SwapInterval - 1 =" << swapInterval << endl;
			break;
		}*/


		// option - toggle fullscreen
	if (a_key == GLFW_KEY_F)
	{
		// toggle state variable
		fullscreen = !fullscreen;

		// get handle to monitor
		GLFWmonitor* monitor = glfwGetPrimaryMonitor();

		// get information about monitor
		const GLFWvidmode* mode = glfwGetVideoMode(monitor);

		// set fullscreen or window mode
		if (fullscreen)
		{
			glfwSetWindowMonitor(window, monitor, 0, 0, mode->width, mode->height, mode->refreshRate);
			glfwSwapInterval(swapInterval);
		}
		else
		{
			int w = 0.8 * mode->height;
			int h = 0.5 * mode->height;
			int x = 0.5 * (mode->width - w);
			int y = 0.5 * (mode->height - h);
			glfwSetWindowMonitor(window, NULL, x, y, w, h, mode->refreshRate);
			glfwSwapInterval(swapInterval);
		}
	}
	// filter calls that only include a key press
	if ((a_action != GLFW_PRESS) && (a_action != GLFW_REPEAT))
	{

		return;
	}

	// option - exit
	if ((a_key == GLFW_KEY_ESCAPE) || (a_key == GLFW_KEY_Q))
	{
		glfwSetWindowShouldClose(a_window, GLFW_TRUE);
	}
	// option - toggle vertical mirroring
	if (a_key == GLFW_KEY_M)
	{
		mirroredDisplay = !mirroredDisplay;
		camera->setMirrorHorizontal(mirroredDisplay);

	}
	// option - enable/disable force field
	if (a_key == GLFW_KEY_1)
	{
		useForceField = !useForceField;
		if (useForceField)
			cout << "> Enable force field     \r";
		else
			cout << "> Disable force field    \r";

	}
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void close(void)
{
	CloseUDP();
	// stop the simulation
	simulationRunning = false;

	// wait for graphics and haptics loops to terminate
	while (!simulationFinished)
	{
		cSleepMs(10);
	}

	// close haptic device
	hapticDevice->close();

	// delete resources
	delete hapticsThread;
	delete world;
	delete handler;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void InitUDP()
{ 
	// À©¼Ó ÃÊ±âÈ
	if (WSAStartup(MAKEWORD(2, 2), &wsa) != 0)
	{
		MessageBox(NULL, "Socket Open Error!!", "UDP", MB_OK);
	}


	// socket()
	sock = socket(AF_INET, SOCK_DGRAM, 0);
	if (sock == INVALID_SOCKET)
	{
		err_quit("socket()");
	}

	// bind()
	ZeroMemory(&serveraddr, sizeof(serveraddr));
	serveraddr.sin_family = AF_INET;
	serveraddr.sin_port = htons(UDP_PORT);
	serveraddr.sin_addr.s_addr = inet_addr(SERVER_IP);
	retval = ::bind(sock, (SOCKADDR*)&serveraddr, sizeof(serveraddr));
	
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CloseUDP()
{
	// closesocket()
	closesocket(sock);

	// À©¼Ó Á¾·á
	WSACleanup();
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////								 EBA									//
////////////////////////////////////////////////////////////////////////////
//void modifiedEBA(void)
//{
//	if (EnableEBA)
//	{
//		c2 = Ke;
//		if (c2 > c1)
//			c2 = c1;
//
//		for (int i = 1; i < 3; i++)
//		{
//			if (DXd[i] != 0.0)
//			{
//				// Control law
//				// Calculation of Beta
//				uBETA[i] = BETA[i] = (dFe[i] - Fd[i]) / DXd[i];
//
//				// Calculation of Gamma_max & Gamma_min
//				Bmax[i] = c2 - Fd[i] / DXd[i] + sqrt(Fd[i] * Fd[i] / DXd[i] / DXd[i] + c2 * c2); //Gamma_max
//				Bmin[i] = c2 - Fd[i] / DXd[i] - sqrt(Fd[i] * Fd[i] / DXd[i] / DXd[i] + c2 * c2); //Gamma_min
//
//				if (Bmax[i] > c1)
//					Bmax[i] = c1; // min(c1, Gamma_max)
//
//				// Bounding Law
//				if (BETA[i] < Bmin[i])
//					BETA[i] = Bmin[i];
//				if (BETA[i] > Bmax[i])
//					BETA[i] = Bmax[i];
//			}
//			else
//			{
//				uBETA[i] = BETA[i];
//				BETA[i] = BETA[i];
//			}
//
//			Fd[i] = Fd[i] + BETA[i] * DXd[i];
//		}
//	}
//
//	else
//	{
//		for (int i = 0; i < 3; i++)
//		{
//			Fd[i] = dFe[i];
//		}
//	}
//}


void UDPSendData(float sData[SENDDATA_NUM])

{
	//	sprintf(sbuf, "%f %f %f %f %f %f %f %f %f %f %f %f %f %f %f %f %f %f %f %f", sData[0], sData[1], sData[2], sData[3], sData[4], sData[5], sData[6], sData[7], sData[8], sData[9], sData[10], sData[11], sData[12], sData[13], sData[14], sData[15], sData[16], sData[17], sData[18], sData[19]);
	Timer time;
	sprintf(sbuf, "%f %f %f %f", sData[0], sData[1], sData[2]);
	retval = sendto(sock, sbuf, strlen(sbuf), 0, (SOCKADDR*)&clientaddr, sizeof(clientaddr));
	if (retval == SOCKET_ERROR)
	{
		err_display("sendto()");
		
		exit(-1);
	}
	cSleepMs(TAP);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void UDPReadData()
{
	Timer2 time;
	addrlen = sizeof(clientaddr);
	retval = recvfrom(sock, rbuf, BUFSIZE, 0, (SOCKADDR*)&clientaddr, &addrlen);
	if (retval == SOCKET_ERROR)
	{
		err_display("recvfrom()");
		exit(-1);
	}
	//	sscanf(rbuf, "%f %f %f %f %f %f %f %f %f %f %f %f %f %f %f %f %f %f %f %f", &ReadData[0], &ReadData[1], &ReadData[2], &ReadData[3], &ReadData[4], &ReadData[5], &ReadData[6], &ReadData[7], &ReadData[8], &ReadData[9], &ReadData[10], &ReadData[11], &ReadData[12], &ReadData[13], &ReadData[14], &ReadData[15], &ReadData[16], &ReadData[17], &ReadData[18], &ReadData[19]);
	(sscanf(rbuf, "%f %f %f %f", &ReadData[0], &ReadData[1], &ReadData[2]));

	delay = timeUDPS - timeUDPR;
	countd = countd++;
	//cSleepMs(0);
	cout << countd << " Delay calculated " << " " << delay << " " << " milliseconds" << endl;
}
void updateGraphics(void)
{
	
	/////////////////////////////////////////////////////////////////////
	// UPDATE WIDGETS
	/////////////////////////////////////////////////////////////////////

	// update position data
	labelHapticDevicePosition->setText(hapticDevicePosition.str(3));

	// update haptic and graphic rate data
	labelRates->setText(cStr(freqCounterGraphics.getFrequency(), 0) + " Hz / " +
		cStr(freqCounterHaptics.getFrequency(), 0) + " Hz");

	// update position of label
	labelRates->setLocalPos((int)(0.5 * (width - labelRates->getWidth())), 15);

	if (delay <= 5)
	{
		delaym = delay;
		avg_delay = 2;
	}
	else if (delay <= 7)
	{
		delaym = delay / 2;
		avg_delay = 4;
	}
	else if (delay <= 9)
	{
		delaym = delay;
		avg_delay = 5;
	}
	else if (delay <= 20)
	{
		delaym = delay / 2;
		avg_delay = 10;
	}
	else if (delay <= 50)
	{
		delaym = delay / 5;
		avg_delay = 25;
	}
	else if (delay <= 100)
	{
		delaym = delay / 10;
		avg_delay = 50;
	}
	else if (delay <= 200)
	{
		delaym = delay / 20;
		avg_delay = 100;
	}
	else if (delay <= 400)
	{
		delaym = delay / 40;
		avg_delay = 200;
	}
	else if (delay <= 600)
	{
		delaym = delay / 60;
		avg_delay = 300;
	}
	else if (delay <= 800)
	{
		delaym = delay / 80;
	}
	else if (delay <= 1000)
	{
		delaym = delay / 100;
	}
	else if (delay <= 1500)
	{
		delaym = delay / 150;
	}
	else if (delay <= 2000)
	{
		delaym = delay / 200;
	}
	else if (delay <= 2500)
	{
		delaym = delay / 250;
	}
	while(TAP!=0)
	{
				
		delaym = delaym + TAP;
		break;
	}
	
	// update information to scope
	scope->setSignalValues(hapticDevicePosition.x(), hapticDevicePosition.y(), hapticDevicePosition.z());
	
	scope1->setSignalValues(delaym + TAP);
	scope2->setSignalValues(delay);

	// update velocity information to level
	levelVelocity->setValue(TAP);

	
	//scope2->setSignalValues(hapticDeviceVelocity.x(), hapticDeviceVelocity.y(), hapticDeviceVelocity.z());


	labelIP->setText("Client IP: " + string(inet_ntoa(clientaddr.sin_addr)) + ":" + cStr(ntohs(clientaddr.sin_port)));
	labelXd_Prev->setText("Prev Xd: " + cStr(pos_prev[0], 3U) + "  " + cStr(pos_prev[1], 3U) + "  " + cStr(pos_prev[2], 3U));
	labelXd->setText("Curr Xd: " + cStr(pos_curr[0], 3U) + "  " + cStr(pos_curr[1], 3U) + "  " + cStr(pos_curr[2], 3U));
	labelX_Recv->setText("Recv X: " + cStr(pos_recv[0], 3U) + "  " + cStr(pos_recv[1], 3U) + "  " + cStr(pos_recv[2], 3U));
	labelFd->setText("Fd: " + cStr(Fd[0], 3U) + "  " + cStr(Fd[1], 3U) + "  " + cStr(Fd[2], 3U));
	labelDelay->setText("Delay: " + cStr(abs(delay), 3U) + "ms");
	labeldelay2->setText("Max: " + cStr(abs(delay+5), 2U) + "ms");
	labeldelay3->setText("AvgDelay: " + cStr(abs(avg_delay), 2U) + "ms");
	

	cVector3d linearVelocity;
	hapticDevice->getLinearVelocity(linearVelocity);

	//cout << "Linear Velocity" << "(" << linearVelocity << ")" << endl;
	/*cout << endl;
	cout << "Prev position:" << "(" << pos_prev[0] << "," << pos_prev[1] << "," << pos_prev[2] << ")" << endl;
	cout << "Curr position:" << "(" << pos_curr[0] << "," << pos_curr[1] << "," << pos_curr[2] << ")" << endl;
	cout << "Recv position:" << "(" << pos_recv[0] << "," << pos_recv[1] << "," << pos_recv[2] << ")" << endl;
*/

/////////////////////////////////////////////////////////////////////
// RENDER SCENE
/////////////////////////////////////////////////////////////////////

// update shadow maps (if any)
	world->updateShadowMaps(false, mirroredDisplay);

	// render world
	camera->renderView(width, height);

	// wait until all OpenGL commands are completed
	glFinish();

	// check for any OpenGL errors
	GLenum err;
	err = glGetError();
	if (err != GL_NO_ERROR) cout << "Error:  %s\n" << gluErrorString(err);
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// ¼ÒÄÏ ÇÔ¼ö ¿À·ù Ãâ·Â ÈÄ Á¾·á
void err_quit(const char* msg)
{
	LPVOID lpMsgBuf;

	FormatMessage(
		FORMAT_MESSAGE_ALLOCATE_BUFFER |
		FORMAT_MESSAGE_FROM_SYSTEM,
		NULL, WSAGetLastError(),
		MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),

		(LPTSTR)&lpMsgBuf, 0, NULL);
	MessageBox(NULL, (LPCTSTR)lpMsgBuf, msg, MB_ICONERROR);
	LocalFree(lpMsgBuf);
	exit(-1);
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// ¼ÒÄÏ ÇÔ¼ö ¿À·ù Ãâ·Â
void err_display(const char* msg)
{
	LPVOID lpMsgBuf;
	FormatMessage(
		FORMAT_MESSAGE_ALLOCATE_BUFFER |
		FORMAT_MESSAGE_FROM_SYSTEM,
		NULL, WSAGetLastError(),
		MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
		(LPTSTR)&lpMsgBuf, 0, NULL);

	printf("[%s] %s", msg, (LPCTSTR)lpMsgBuf);
	LocalFree(lpMsgBuf);
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
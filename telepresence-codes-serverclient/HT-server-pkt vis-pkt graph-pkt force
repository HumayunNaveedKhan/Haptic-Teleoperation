#include <G:\My Drive\My degrees and Courses\MEngg. (Computer Networks)\HK MEngg Thesis\Haptic Teleoperation (06-12-2024)\chai3d-3.2.0\external\glew\include\GL\glew.h>  // GLEW should be included before any OpenGL headers
#include <G:\My Drive\My degrees and Courses\MEngg. (Computer Networks)\HK MEngg Thesis\Haptic Teleoperation (06-12-2024)\chai3d-3.2.0\extras\freeglut\include\GL\glut.h>  // OpenGL Utility Toolkit
#include <iostream>
#include <deque>
#include <vector>
#include <thread>
#include <mutex>
#include <chrono>
#include <cmath>
#include <cstring>
#include <winsock2.h>
#include <ws2tcpip.h>
#include "G:\My Drive\My degrees and Courses\MEngg. (Computer Networks)\HK MEngg Thesis\Haptic Teleoperation (06-12-2024)\chai3d-3.2.0\src\chai3d.h"

#pragma comment(lib, "ws2_32.lib") // Link Winsock library

#define PORT 4000
#define MAX_PACKETS 5000  // Store last 5000 packets
using namespace chai3d;

std::mutex dataMutex;
std::deque<float> packetMagnitudes;
std::deque<std::string> packetTimestamps;
int receivedPackets = 0, lostPackets = 0, lastSequenceNumber = -1;
float zoomFactor = 1.0f;
bool running = true;

// Chai3D variables
chai3d::cWorld* world;
chai3d::cCamera* camera;
chai3d::cShapeSphere* hapticCursor;
chai3d::cVector3d toolPos(0.0, 0.0, 0.0);
cSpotLight* light;

// UDP packet structure
struct Packet {
    int sequenceNumber;
    float x, y, z;
    float delay;
    char timestamp[32];
};

// ✅ **UDP Receiver Thread**
void udpReceiver() {
    WSADATA wsaData;
    SOCKET sockfd;
    struct sockaddr_in servaddr, cliaddr;
    int cliLen = sizeof(cliaddr);

    if (WSAStartup(MAKEWORD(2, 2), &wsaData) != 0) {
        std::cerr << "[ERROR] WSAStartup failed!\n";
        return;
    }

    sockfd = socket(AF_INET, SOCK_DGRAM, 0);
    if (sockfd == INVALID_SOCKET) {
        std::cerr << "[ERROR] Socket creation failed: " << WSAGetLastError() << "\n";
        WSACleanup();
        return;
    }

    servaddr.sin_family = AF_INET;
    servaddr.sin_addr.s_addr = INADDR_ANY;
    servaddr.sin_port = htons(PORT);

    if (bind(sockfd, (struct sockaddr*)&servaddr, sizeof(servaddr)) == SOCKET_ERROR) {
        std::cerr << "[ERROR] Bind failed: " << WSAGetLastError() << "\n";
        closesocket(sockfd);
        WSACleanup();
        return;
    }

    std::cout << "[INFO] UDP server listening on port " << PORT << "...\n";

    while (running) {
        Packet packet;
        int n = recvfrom(sockfd, (char*)&packet, sizeof(packet), 0, (struct sockaddr*)&cliaddr, &cliLen);
        if (n > 0) {
            std::lock_guard<std::mutex> lock(dataMutex);

            // ✅ Print received data for debugging
            std::cout << "[RECEIVED] Seq: " << packet.sequenceNumber
                << " | X: " << packet.x
                << " | Y: " << packet.y
                << " | Z: " << packet.z
                << " | Delay: " << packet.delay
                << " | Timestamp: " << packet.timestamp << "\n";

            float magnitude = sqrt(packet.x * packet.x + packet.y * packet.y + packet.z * packet.z);

            if (lastSequenceNumber != -1 && packet.sequenceNumber != lastSequenceNumber + 1) {
                lostPackets += (packet.sequenceNumber - lastSequenceNumber - 1);
            }
            lastSequenceNumber = packet.sequenceNumber;

            packetMagnitudes.push_back(magnitude);
            packetTimestamps.push_back(std::string(packet.timestamp));
            receivedPackets++;

            toolPos = chai3d::cVector3d(packet.x, packet.y, packet.z);

            if (packetMagnitudes.size() > MAX_PACKETS) {
                packetMagnitudes.pop_front();
                packetTimestamps.pop_front();
            }
        }
        else {
            std::cerr << "[WARNING] No data received. Error: " << WSAGetLastError() << "\n";
        }
    }

    closesocket(sockfd);
    WSACleanup();
}


// ✅ **OpenGL Display Function (Packet Graph)**
void display() {
    glClear(GL_COLOR_BUFFER_BIT);
    glLoadIdentity();
    glScalef(zoomFactor, zoomFactor, 1.0f);

    std::lock_guard<std::mutex> lock(dataMutex);

    glColor3f(0.0, 1.0, 0.0);
    glBegin(GL_LINE_STRIP);
    for (size_t i = 0; i < packetMagnitudes.size(); i++) {
        float x = (i / (float)MAX_PACKETS) * 2.0f - 1.0f;
        float y = (packetMagnitudes[i] / 100.0f) * 2.0f - 1.0f;
        glVertex2f(x, y);
    }
    glEnd();

    glColor3f(1.0, 1.0, 1.0);
    glRasterPos2f(-0.9f, 0.9f);
    std::string stats = "Packets: " + std::to_string(receivedPackets) + " | Lost: " + std::to_string(lostPackets);
    for (char c : stats) glutBitmapCharacter(GLUT_BITMAP_HELVETICA_18, c);

    glutSwapBuffers();
}

// ✅ **OpenGL Reshape Function**
void reshape(int w, int h) {
    glViewport(0, 0, w, h);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    gluOrtho2D(-1, 1, -1, 1);
    glMatrixMode(GL_MODELVIEW);
}

// ✅ **OpenGL Timer Function for Refresh**
void timer(int) {
    glutPostRedisplay();
    glutTimerFunc(33, timer, 0);
}

// ✅ **Chai3D Render Function**
void chaiRender() {
    while (running) {
        std::lock_guard<std::mutex> lock(dataMutex);
        hapticCursor->setLocalPos(toolPos);
        world->computeGlobalPositions();
        std::this_thread::sleep_for(std::chrono::milliseconds(10));
    }
}

// ✅ **Initialize Chai3D Scene**
void initChai3D() {
    world = new chai3d::cWorld();
    camera = new chai3d::cCamera(world);
    world->addChild(camera);
    camera->set(chai3d::cVector3d(0.0, 0.0, 2.0), chai3d::cVector3d(0.0, 0.0, 0.0), chai3d::cVector3d(0.0, 1.0, 0.0));

    light = new cSpotLight(world);
    camera->addChild(light);
    light->setEnabled(true);

    hapticCursor = new chai3d::cShapeSphere(0.05);
    world->addChild(hapticCursor);
    hapticCursor->setLocalPos(0.0, 0.0, 0.0);
}

// ✅ **Main Function**
int main(int argc, char** argv) {
    std::thread udpThread(udpReceiver);

    glutInit(&argc, argv);
    glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB);
    glutInitWindowSize(800, 600);
    glutCreateWindow("UDP Packet Graph");

    glewInit();  // Initialize GLEW after creating the OpenGL context

    glutDisplayFunc(display);
    glutReshapeFunc(reshape);
    glutTimerFunc(33, timer, 0);

    initChai3D();
    std::thread chaiThread(chaiRender);

    glutMainLoop();

    running = false;  // Stop threads gracefully
    udpThread.join();
    chaiThread.join();

    return 0;
}
